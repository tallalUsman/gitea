{"version":3,"file":"js/pdfobject.xxxxxxxx.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,IAA0C;AAClD;AACA,QAAQ,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AAC3B,MAAM,KAAK,EAQR;AACH,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA,qHAAqH;;AAErH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA,2CAA2C;;AAE3C;;AAEA;AACA;;AAEA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA,oDAAoD;;AAEpD;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,UAAU;;AAEV;AACA;;AAEA,UAAU;;AAEV;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;;AAEA,sCAAsC;;AAEtC;AACA;AACA,gDAAgD,uBAAuB;AACvE,cAAc;AACd;AACA,8CAA8C,QAAQ,UAAU,WAAW,SAAS,aAAa,aAAa;AAC9G;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;;AAErC;AACA,yBAAyB;;AAEzB;AACA,kBAAkB;;AAElB;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAc;;AAEd;AACA,qDAAqD;;AAErD;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,iCAAiC,sBAAsB;AACvD,yCAAyC,0BAA0B;AACnE,oCAAoC,sBAAsB;AAC1D;;AAEA,CAAC","sources":["webpack:///./node_modules/pdfobject/pdfobject.js"],"sourcesContent":["/**\n *  PDFObject v2.3.0\n *  https://github.com/pipwerks/PDFObject\n *  @license\n *  Copyright (c) 2008-2024 Philip Hutchison\n *  MIT-style license: http://pipwerks.mit-license.org/\n *  UMD module pattern from https://github.com/umdjs/umd/blob/master/templates/returnExports.js\n */\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.PDFObject = factory();\n  }\n}(this, function () {\n\n    \"use strict\";\n\n    //PDFObject is designed for client-side (browsers), not server-side (node)\n    //Will choke on undefined navigator and window vars when run on server\n    //Return boolean false and exit function when running server-side\n\n    if(typeof window === \"undefined\" || window.navigator === undefined || window.navigator.userAgent === undefined){ return false; }\n\n    let pdfobjectversion = \"2.3.0\";\n    let win = window;\n    let nav = win.navigator;\n    let ua = nav.userAgent;\n    let suppressConsole = false;\n\n    //Fallback validation when navigator.pdfViewerEnabled is not supported\n    let isModernBrowser = function (){\n\n        /*\n           userAgent sniffing is not the ideal path, but most browsers revoked the ability to check navigator.mimeTypes \n           for security purposes. As of 2023, browsers have begun implementing navigator.pdfViewerEnabled, but older versions\n           do not have navigator.pdfViewerEnabled or the ability to check navigator.mimeTypes. We're left with basic browser \n           sniffing and assumptions of PDF support based on browser vendor.\n        */\n\n        //Chromium has provided native PDF support since 2011.\n        //Most modern browsers use Chromium under the hood: Google Chrome, Microsoft Edge, Opera, Brave, Vivaldi, Arc, and more.\n        //Chromium uses the PDFium rendering engine, which is based on Foxit's PDF rendering engine.\n        //Note that MS Edge opts to use a different PDF rendering engine. As of 2024, Edge uses a version of Adobe's Reader\n        let isChromium = (win.chrome !== undefined);\n\n        //Safari on macOS has provided native PDF support since 2009. \n        //This code snippet also detects the DuckDuckGo browser, which uses Safari/Webkit under the hood.\n        let isSafari = (win.safari !== undefined || (nav.vendor !== undefined && /Apple/.test(nav.vendor) && /Safari/.test(ua)));\n\n        //Firefox has provided PDF support via PDFJS since 2013.\n        let isFirefox = (win.Mozilla !== undefined || /irefox/.test(ua));\n\n        return isChromium || isSafari || isFirefox;  \n\n    };\n\n    /*\n       Special handling for Internet Explorer 11.\n       Check for ActiveX support, then whether \"AcroPDF.PDF\" or \"PDF.PdfCtrl\" are valid.\n       IE11 uses ActiveX for Adobe Reader and other PDF plugins, but window.ActiveXObject will evaluate to false. \n       (\"ActiveXObject\" in window) evaluates to true.\n       MS Edge does not support ActiveX so this test will evaluate false for MS Edge.\n    */\n    let validateAX = function (type){\n        var ax = null;\n        try {\n            ax = new ActiveXObject(type);\n        } catch (e) {\n            //ensure ax remains null when ActiveXObject attempt fails\n            ax = null;\n        }\n        return !!ax; //convert resulting object to boolean\n    };\n\n    let hasActiveXPDFPlugin = function (){ return (\"ActiveXObject\" in win) && (validateAX(\"AcroPDF.PDF\") || validateAX(\"PDF.PdfCtrl\")) };\n\n    let checkSupport = function (){\n\n        //Safari on iPadOS doesn't report as 'mobile' when requesting desktop site, yet still fails to embed PDFs\n        let isSafariIOSDesktopMode = (nav.platform !== undefined && nav.platform === \"MacIntel\" && nav.maxTouchPoints !== undefined && nav.maxTouchPoints > 1);\n\n        let isMobileDevice = (isSafariIOSDesktopMode || /Mobi|Tablet|Android|iPad|iPhone/.test(ua));\n\n        //As of June 2023, no mobile browsers properly support inline PDFs. If mobile, just say no.\n        if(isMobileDevice){ return false; }\n        \n        //Modern browsers began supporting navigator.pdfViewerEnabled in late 2022 and early 2023.\n        let supportsPDFVE = (typeof nav.pdfViewerEnabled === \"boolean\");\n\n        //If browser supports nav.pdfViewerEnabled and is explicitly saying PDFs are NOT supported (e.g. PDFJS disabled by user in Firefox), respect it.\n        if(supportsPDFVE && !nav.pdfViewerEnabled){ return false; }\n\n        return (supportsPDFVE && nav.pdfViewerEnabled) || isModernBrowser() || hasActiveXPDFPlugin();\n\n    };\n\n    //Determines whether PDF support is available\n    let supportsPDFs = checkSupport();\n\n    //Create a fragment identifier for using PDF Open parameters when embedding PDF\n    let buildURLFragmentString = function(pdfParams){\n\n        let string = \"\";\n        let prop;\n        let paramArray = [];\n        let fdf = \"\";\n        \n        //The comment, viewrect, and highlight parameters require page to be set first. \n\n        //Check to ensure page is used if comment, viewrect, or highlight are specified\n        if(pdfParams.comment || pdfParams.viewrect || pdfParams.highlight){\n\n            if(!pdfParams.page){\n                \n                //If page is not set, use the first page\n                pdfParams.page = 1;\n                \n                //Inform user that page needs to be set properly\n                embedError(\"The comment, viewrect, and highlight parameters require a page parameter, but none was specified. Defaulting to page 1.\");\n            \n            }\n\n        }\n\n        //Let's go ahead and ensure page is always the first parameter.\n        if(pdfParams.page){\n            paramArray.push(\"page=\" + encodeURIComponent(pdfParams.page));\n            delete pdfParams.page;\n        }\n\n        //FDF needs to be the last parameter in the string\n        if(pdfParams.fdf){\n            fdf = pdfParams.fdf;\n            delete pdfParams.fdf;\n        }\n        \n        //Add all other parameters, as needed\n        if(pdfParams){\n\n            for (prop in pdfParams) {\n                if (pdfParams.hasOwnProperty(prop)) {\n                    paramArray.push(encodeURIComponent(prop) + \"=\" + encodeURIComponent(pdfParams[prop]));\n                }\n            }\n\n            //Add fdf as the last parameter, if needed\n            if(fdf){\n                paramArray.push(\"fdf=\" + encodeURIComponent(fdf));\n            }\n\n            //Join all parameters in the array into a string\n            string = paramArray.join(\"&\");\n\n            //The string will be empty if no PDF Parameters were provided\n            //Only prepend the hash if the string is not empty\n            if(string){\n                string = \"#\" + string;\n            }\n\n        }\n\n        return string;\n\n    };\n\n    let embedError = function (msg){\n        if(!suppressConsole){\n            console.log(\"[PDFObject]\", msg);\n        }\n        return false;\n    };\n\n    let emptyNodeContents = function (node){\n        while(node.firstChild){\n            node.removeChild(node.firstChild);\n        }\n    };\n\n    let getTargetElement = function (targetSelector){\n\n        //Default to body for full-browser PDF\n        let targetNode = document.body;\n\n        //If a targetSelector is specified, check to see whether\n        //it's passing a selector, jQuery object, or an HTML element\n\n        if(typeof targetSelector === \"string\"){\n\n            //Is CSS selector\n            targetNode = document.querySelector(targetSelector);\n\n        } else if (win.jQuery !== undefined && targetSelector instanceof jQuery && targetSelector.length) {\n\n            //Is jQuery element. Extract HTML node\n            targetNode = targetSelector.get(0);\n\n        } else if (targetSelector.nodeType !== undefined && targetSelector.nodeType === 1){\n\n            //Is HTML element\n            targetNode = targetSelector;\n\n        }\n\n        return targetNode;\n\n    };\n\n    let convertBase64ToDownloadableLink = function (b64, filename, targetNode, fallbackHTML) {\n\n        //IE-11 safe version. More verbose than modern fetch()\n        if (window.Blob && window.URL && window.URL.createObjectURL) {\n\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', b64, true);\n            xhr.responseType = 'blob';\n            xhr.onload = function() {\n\n                if (xhr.status === 200) {\n \n                    var blob = xhr.response;\n                    var link = document.createElement('a');\n                    link.innerText = \"Download PDF\";\n                    link.href = URL.createObjectURL(blob);\n                    link.setAttribute('download', filename);\n                    targetNode.innerHTML = fallbackHTML.replace(/\\[pdflink\\]/g, link.outerHTML);\n\n                }\n\n            };\n\n            xhr.send();\n            \n        }\n\n    };\n\n\n    let generatePDFObjectMarkup = function (embedType, targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL){\n\n        //Ensure target element is empty first\n        emptyNodeContents(targetNode);\n\n        let source = url;\n\n        if(embedType === \"pdfjs\"){ \n            //If PDFJS_URL already contains a ?, assume querystring is in place, and use an ampersand to append PDFJS's file parameter\n            let connector = (PDFJS_URL.indexOf(\"?\") !== -1) ? \"&\" : \"?\"; \n            source = PDFJS_URL + connector + \"file=\" + encodeURIComponent(url) + pdfOpenFragment;\n        } else {\n            source += pdfOpenFragment;\n        }\n\n        let el = document.createElement(\"iframe\");\n        el.className = \"pdfobject\";\n        el.type = \"application/pdf\";\n        el.title = title;\n        el.src = source;\n        el.allow = \"fullscreen\";\n        el.frameborder = \"0\";\n        if(id){ el.id = id; }\n\n        if(!omitInlineStyles){\n\n            let style = \"border: none;\";\n\n            if(targetNode !== document.body){\n                //assign width and height to target node\n                style += \"width: \" + width + \"; height: \" + height + \";\";\n            } else {\n                //this is a full-page embed, use CSS to fill the viewport\n                style += \"position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%;\";\n            }\n\n            el.style.cssText = style; \n\n        }\n\n        //Allow developer to insert custom attribute on iframe element, but ensure it does not conflict with attributes used by PDFObject\n        let reservedTokens = [\"className\", \"type\", \"title\", \"src\", \"style\", \"id\", \"allow\", \"frameborder\"];\n        if(customAttribute && customAttribute.key && reservedTokens.indexOf(customAttribute.key) === -1){\n            el.setAttribute(customAttribute.key, (typeof customAttribute.value !== \"undefined\") ? customAttribute.value : \"\");\n        }\n\n        targetNode.classList.add(\"pdfobject-container\");\n        targetNode.appendChild(el);\n\n        return targetNode.getElementsByTagName(\"iframe\")[0];\n\n    };\n\n    let embed = function(url, targetSelector, options){\n\n        //If targetSelector is not defined, convert to boolean\n        let selector = targetSelector || false;\n\n        //Ensure options object is not undefined -- enables easier error checking below\n        let opt = options || {};\n\n        //Get passed options, or set reasonable defaults\n        suppressConsole = (typeof opt.suppressConsole === \"boolean\") ? opt.suppressConsole : false;\n        let id = (typeof opt.id === \"string\") ? opt.id : \"\";\n        let page = opt.page || false;\n        let pdfOpenParams = opt.pdfOpenParams || {};\n        let fallbackLink = (typeof opt.fallbackLink === \"string\" || typeof opt.fallbackLink === \"boolean\") ? opt.fallbackLink : true;\n        let width = opt.width || \"100%\";\n        let height = opt.height || \"100%\";\n        let title = opt.title || \"Embedded PDF\";\n        let forcePDFJS = (typeof opt.forcePDFJS === \"boolean\") ? opt.forcePDFJS : false;\n        let omitInlineStyles = (typeof opt.omitInlineStyles === \"boolean\") ? opt.omitInlineStyles : false;\n        let PDFJS_URL = opt.PDFJS_URL || false;\n        let targetNode = getTargetElement(selector);\n        let pdfOpenFragment = \"\";\n        let customAttribute = opt.customAttribute || {};\n        let fallbackHTML_default = \"<p>This browser does not support inline PDFs. Please download the PDF to view it: [pdflink]</p>\";\n\n        //Ensure URL is available. If not, exit now.\n        if(typeof url !== \"string\"){ return embedError(\"URL is not valid\"); }\n\n        //If target element is specified but is not valid, exit without doing anything\n        if(!targetNode){ return embedError(\"Target element cannot be determined\"); }\n\n        //page option overrides pdfOpenParams, if found\n        if(page){ pdfOpenParams.page = page; }\n\n        //Stringify optional Adobe params for opening document (as fragment identifier)\n        pdfOpenFragment = buildURLFragmentString(pdfOpenParams);\n\n\n        // --== Do the dance: Embed attempt #1 ==--\n\n        //If the forcePDFJS option is invoked, skip everything else and embed as directed\n        if(forcePDFJS && PDFJS_URL){\n            return generatePDFObjectMarkup(\"pdfjs\", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);\n        }\n \n        // --== Embed attempt #2 ==--\n\n        //Embed PDF if support is detected, or if this is a relatively modern browser \n        if(supportsPDFs){\n            return generatePDFObjectMarkup(\"iframe\", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute);\n        }\n        \n        // --== Embed attempt #3 ==--\n        \n        //If everything else has failed and a PDFJS fallback is provided, try to use it\n        if(PDFJS_URL){\n            return generatePDFObjectMarkup(\"pdfjs\", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);\n        }\n        \n        // --== PDF embed not supported! Use fallback ==-- \n\n        //Display the fallback link if available\n        if(fallbackLink){\n\n            //If a custom fallback has been provided, handle it now\n            if(typeof fallbackLink === \"string\"){\n\n                //Ensure [url] is set in custom fallback\n                targetNode.innerHTML = fallbackLink.replace(/\\[url\\]/g, url);\n\n            } else {\n\n                //If the PDF is a base64 string, convert it to a downloadable link\n                if(url.indexOf(\"data:application/pdf;base64\") !== -1){\n\n                    //Asynchronously append the link to the targetNode\n                    convertBase64ToDownloadableLink(url, \"file.pdf\", targetNode, fallbackHTML_default);\n                \n                } else {\n\n                    //Use default fallback link\n                    let link = \"<a href='\" + url + \"'>Download PDF</a>\";\n                    targetNode.innerHTML = fallbackHTML_default.replace(/\\[pdflink\\]/g, link);\n\n                }\n\n            }\n\n        }\n\n        return embedError(\"This browser does not support embedded PDFs\");\n\n    };\n\n    return {\n        embed: function (a,b,c){ return embed(a,b,c); },\n        pdfobjectversion: (function () { return pdfobjectversion; })(),\n        supportsPDFs: (function (){ return supportsPDFs; })()\n    };\n\n}));"],"names":[],"sourceRoot":""}