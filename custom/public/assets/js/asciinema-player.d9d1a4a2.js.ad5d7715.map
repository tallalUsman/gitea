{"version":3,"file":"js/asciinema-player.xxxxxxxx.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAwD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,cAAc,KAAK,EAAE,EAAC;AACtB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA,2BAA2B;AAC3B;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,qDAAqD,iDAAiD;AACtG,iDAAiD,oEAAoE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA,OAAO;AACP;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD,yCAAyC;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV,QAAQ;AACR;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB,gBAAgB,KAAK;AACrB,MAAM,eAAe,KAAK;AAC1B,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA,MAAM,4DAA4D;AAClE;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,0GAA0G;AAC1G,QAAQ;AACR;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,IAAI,YAAY,IAAI,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,UAAU,SAAS;AACnB,UAAU,QAAQ;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,eAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK,GAAG,KAAK;AACzD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wCAAwC,KAAK,GAAG,KAAK;AACrD;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK,GAAG,KAAK;AACzD;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA,IAAI;AACJ,sDAAsD,QAAQ;AAC9D;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,MAAM;AACN,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR,yBAAyB,SAAS;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,8IAA8I;AACpN;AACA;AACA;AACA;AACA,kEAAkE,gKAAgK;AAClO;AACA;AACA;AACA,wBAAwB,aAAa;AACrC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,EAAE,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B,iBAAiB,0BAA0B;AAC3C,sBAAsB,2BAA2B;AACjD;AACA,wBAAwB,aAAa;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,oBAAoB,aAAa;AACjC,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW;AACnE,IAAI;AACJ,cAAc,WAAW,GAAG,WAAW,GAAG,WAAW;AACrD,IAAI;AACJ,cAAc,WAAW,GAAG,WAAW;AACvC;AACA;AACA;AACA,sBAAsB,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4BAA4B;AAC7D;AACA;AACA;AACA,MAAM;AACN,gBAAgB,kBAAkB,IAAI,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;;AAEA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qCAAqC,IAAI;AACzC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,MAAM;AACN,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA,mBAAmB,UAAU;AAC7B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE;AAChC,OAAO;AACP;AACA;AACA;AACA,gEAAgE,2BAA2B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA,oDAAoD;AACpD;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA,mDAAmD;AACnD;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,aAAa;AACxG;AACA;AACA,uBAAuB,YAAY,EAAE,QAAQ;AAC7C;AACA;AACA,+FAA+F,eAAe;AAC9G;AACA;AACA,yBAAyB,YAAY,EAAE,QAAQ;AAC/C;AACA;AACA,+FAA+F,eAAe;AAC9G;AACA;AACA,wBAAwB,YAAY,EAAE,QAAQ;AAC9C;AACA;AACA,+FAA+F,eAAe;AAC9G;AACA;AACA,wBAAwB,YAAY,EAAE,QAAQ;AAC9C;AACA;AACA,+FAA+F,eAAe;AAC9G;AACA;AACA,yBAAyB,YAAY,EAAE,QAAQ;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC,uCAAuC,EAAE,GAAG,GAAG,aAAa,EAAE;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,OAAO,IAAI,OAAO;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI,IAAI,iBAAiB,EAAE,oBAAoB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,yCAAyC,aAAa;AACtD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,iBAAiB,EAAE,aAAa,EAAE,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI,YAAY,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE,MAAM,EAAE,MAAM;AAC/C,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA,iBAAiB,EAAE;AACnB,uBAAuB,gBAAgB;AACvC,uBAAuB,YAAY;AACnC;AACA;AACA;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,2CAA2C,EAAE,MAAM,EAAE,MAAM;AAC3D;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,YAAY;AAC7E,QAAQ;AACR;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,mDAAmD,OAAO;AAC1D;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,cAAc,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mCAAmC,KAAK,GAAG,KAAK;AAChD,MAAM;AACN;AACA;AACA,MAAM;AACN,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa,EAAE,aAAa,EAAE,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK,GAAG,MAAM,GAAG,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,oCAAoC,KAAK,GAAG,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iCAAiC,KAAK,GAAG,KAAK;AAC9C,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;AC9mJlB","sources":["webpack:///./node_modules/asciinema-player/dist/index.js","webpack:///./node_modules/asciinema-player/dist/bundle/asciinema-player.css?0be0"],"sourcesContent":["const sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nvar Owner = null;\nlet Transition = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n    owner = Owner,\n    unowned = fn.length === 0,\n    root = unowned ? UNOWNED : {\n      owned: null,\n      cleanups: null,\n      context: null,\n      owner: detachedOwner === undefined ? owner : detachedOwner\n    },\n    updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE);\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction getListener() {\n  return Listener;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()));\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nfunction readSignal() {\n  const runningTransition = Transition ;\n  if (this.sources && (this.state || runningTransition )) {\n    if (this.state === STALE || runningTransition ) updateComputation(this);else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current = node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition && Transition.running;\n          if (TransitionRunning && Transition.disposed.has(o)) ;\n          if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n            if (o.pure) Updates.push(o);else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (TransitionRunning) ;else o.state = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (false) ;\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n    listener = Listener,\n    time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, node.value, time);\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue);\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition ;\n  if (node.state === 0 || runningTransition ) return;\n  if (node.state === PENDING || runningTransition ) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (node.state || runningTransition ) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (node.state === STALE || runningTransition ) {\n      updateComputation(node);\n    } else if (node.state === PENDING || runningTransition ) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction runUserEffects(queue) {\n  let i,\n    userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition ;\n  node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (source.state === STALE || runningTransition ) {\n        if (source !== ignore) runTop(source);\n      } else if (source.state === PENDING || runningTransition ) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition ;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!o.state || runningTransition ) {\n      o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n        index = node.sourceSlots.pop(),\n        obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n          s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  node.state = 0;\n  node.context = null;\n}\nfunction castError(err) {\n  if (err instanceof Error || typeof err === \"string\") return err;\n  return new Error(\"Unknown error\");\n}\nfunction handleError(err) {\n  err = castError(err);\n  throw err;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    len = 0,\n    indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n      i,\n      j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n        newIndices,\n        newIndicesNext,\n        temp,\n        tempdisposers,\n        tempIndexes,\n        start,\n        end,\n        newEnd,\n        item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    signals = [],\n    len = 0,\n    i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\nfunction createComponent(Comp, props) {\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return !(s = typeof s === \"function\" ? s() : s) ? {} : s;\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i = 0; i < sources.length; i++) {\n    const s = sources[i];\n    proxy = proxy || !!s && $PROXY in s;\n    sources[i] = typeof s === \"function\" ? (proxy = true, createMemo(s)) : s;\n  }\n  if (proxy) {\n    return new Proxy({\n      get(property) {\n        for (let i = sources.length - 1; i >= 0; i--) {\n          const v = resolveSource(sources[i])[property];\n          if (v !== undefined) return v;\n        }\n      },\n      has(property) {\n        for (let i = sources.length - 1; i >= 0; i--) {\n          if (property in resolveSource(sources[i])) return true;\n        }\n        return false;\n      },\n      keys() {\n        const keys = [];\n        for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n        return [...new Set(keys)];\n      }\n    }, propTraps);\n  }\n  const target = {};\n  for (let i = sources.length - 1; i >= 0; i--) {\n    if (sources[i]) {\n      const descriptors = Object.getOwnPropertyDescriptors(sources[i]);\n      for (const key in descriptors) {\n        if (key in target) continue;\n        Object.defineProperty(target, key, {\n          enumerable: true,\n          get() {\n            for (let i = sources.length - 1; i >= 0; i--) {\n              const v = (sources[i] || {})[key];\n              if (v !== undefined) return v;\n            }\n          }\n        });\n      }\n    }\n  }\n  return target;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const keyed = props.keyed;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      strictEqual = keyed || fn;\n      return fn ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  }, undefined, undefined);\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  let keyed = false;\n  const equals = (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];\n  const conditions = children(() => props.children),\n    evalConditions = createMemo(() => {\n      let conds = conditions();\n      if (!Array.isArray(conds)) conds = [conds];\n      for (let i = 0; i < conds.length; i++) {\n        const c = conds[i].when;\n        if (c) {\n          keyed = !!conds[i].keyed;\n          return [i, c, conds[i]];\n        }\n      }\n      return [-1];\n    }, undefined, {\n      equals\n    });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    const fn = typeof c === \"function\" && c.length > 0;\n    strictEqual = keyed || fn;\n    return fn ? untrack(() => c(when)) : c;\n  }, undefined, undefined);\n}\nfunction Match(props) {\n  return props;\n}\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n    aEnd = a.length,\n    bEnd = bLength,\n    aStart = 0,\n    bStart = 0,\n    after = a[aEnd - 1].nextSibling,\n    map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n            sequence = 1,\n            t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction className$1(node, value) {\n  if (value == null) node.removeAttribute(\"class\");else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = e => handlerFn.call(node, handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction style$1(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = undefined);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) {\n    sharedConfig.done = true;\n    document.querySelectorAll(\"[id^=pl-]\").forEach(elem => {\n      while (elem && elem.nodeType !== 8 && elem.nodeValue !== \"pl-\" + e) {\n        let x = elem.nextSibling;\n        elem.remove();\n        elem = x;\n      }\n      elem && elem.remove();\n    });\n  }\n  while (node) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node = node._$host || node.parentNode || node.host;\n  }\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current) current = [...parent.childNodes];\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n    multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (sharedConfig.context) return current;\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context) {\n      if (!array.length) return current;\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode) return current = multi ? [value] : value;\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n      prev = current && current[i];\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if ((typeof item) === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) {\n        normalized.push(prev);\n      } else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\n\nlet wasm;\nconst heap = new Array(128).fill(undefined);\nheap.push(undefined, null, true, false);\nfunction getObject(idx) {\n  return heap[idx];\n}\nlet heap_next = heap.length;\nfunction dropObject(idx) {\n  if (idx < 132) return;\n  heap[idx] = heap_next;\n  heap_next = idx;\n}\nfunction takeObject(idx) {\n  const ret = getObject(idx);\n  dropObject(idx);\n  return ret;\n}\nconst cachedTextDecoder = new TextDecoder('utf-8', {\n  ignoreBOM: true,\n  fatal: true\n});\ncachedTextDecoder.decode();\nlet cachedUint8Memory0 = null;\nfunction getUint8Memory0() {\n  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8Memory0;\n}\nfunction getStringFromWasm0(ptr, len) {\n  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length) heap.push(heap.length + 1);\n  const idx = heap_next;\n  heap_next = heap[idx];\n  heap[idx] = obj;\n  return idx;\n}\nfunction debugString(val) {\n  // primitive types\n  const type = typeof val;\n  if (type == 'number' || type == 'boolean' || val == null) {\n    return `${val}`;\n  }\n  if (type == 'string') {\n    return `\"${val}\"`;\n  }\n  if (type == 'symbol') {\n    const description = val.description;\n    if (description == null) {\n      return 'Symbol';\n    } else {\n      return `Symbol(${description})`;\n    }\n  }\n  if (type == 'function') {\n    const name = val.name;\n    if (typeof name == 'string' && name.length > 0) {\n      return `Function(${name})`;\n    } else {\n      return 'Function';\n    }\n  }\n  // objects\n  if (Array.isArray(val)) {\n    const length = val.length;\n    let debug = '[';\n    if (length > 0) {\n      debug += debugString(val[0]);\n    }\n    for (let i = 1; i < length; i++) {\n      debug += ', ' + debugString(val[i]);\n    }\n    debug += ']';\n    return debug;\n  }\n  // Test for built-in\n  const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n  let className;\n  if (builtInMatches.length > 1) {\n    className = builtInMatches[1];\n  } else {\n    // Failed to match the standard '[object ClassName]'\n    return toString.call(val);\n  }\n  if (className == 'Object') {\n    // we're a user defined class or Object\n    // JSON.stringify avoids problems with cycles, and is generally much\n    // easier than looping through ownProperties of `val`.\n    try {\n      return 'Object(' + JSON.stringify(val) + ')';\n    } catch (_) {\n      return 'Object';\n    }\n  }\n  // errors\n  if (val instanceof Error) {\n    return `${val.name}: ${val.message}\\n${val.stack}`;\n  }\n  // TODO we could test for more things here, like `Set`s and `Map`s.\n  return className;\n}\nlet WASM_VECTOR_LEN = 0;\nconst cachedTextEncoder = new TextEncoder('utf-8');\nconst encodeString = typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) {\n  return cachedTextEncoder.encodeInto(arg, view);\n} : function (arg, view) {\n  const buf = cachedTextEncoder.encode(arg);\n  view.set(buf);\n  return {\n    read: arg.length,\n    written: buf.length\n  };\n};\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === undefined) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr = malloc(buf.length);\n    getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr;\n  }\n  let len = arg.length;\n  let ptr = malloc(len);\n  const mem = getUint8Memory0();\n  let offset = 0;\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 0x7F) break;\n    mem[ptr + offset] = code;\n  }\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, len = offset + arg.length * 3);\n    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n    offset += ret.written;\n  }\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\nlet cachedInt32Memory0 = null;\nfunction getInt32Memory0() {\n  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n  return cachedInt32Memory0;\n}\n/**\n* @param {number} cols\n* @param {number} rows\n* @param {boolean} resizable\n* @param {number} scrollback_limit\n* @returns {VtWrapper}\n*/\nfunction create$1(cols, rows, resizable, scrollback_limit) {\n  const ret = wasm.create(cols, rows, resizable, scrollback_limit);\n  return VtWrapper.__wrap(ret);\n}\nlet cachedUint32Memory0 = null;\nfunction getUint32Memory0() {\n  if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n    cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n  }\n  return cachedUint32Memory0;\n}\nfunction getArrayU32FromWasm0(ptr, len) {\n  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n*/\nclass VtWrapper {\n  static __wrap(ptr) {\n    const obj = Object.create(VtWrapper.prototype);\n    obj.ptr = ptr;\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.ptr;\n    this.ptr = 0;\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_vtwrapper_free(ptr);\n  }\n  /**\n  * @param {string} s\n  * @returns {any}\n  */\n  feed(s) {\n    const ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.vtwrapper_feed(this.ptr, ptr0, len0);\n    return takeObject(ret);\n  }\n  /**\n  * @returns {string}\n  */\n  inspect() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.vtwrapper_inspect(retptr, this.ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      return getStringFromWasm0(r0, r1);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n      wasm.__wbindgen_free(r0, r1);\n    }\n  }\n  /**\n  * @returns {Uint32Array}\n  */\n  get_size() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.vtwrapper_get_size(retptr, this.ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      var v0 = getArrayU32FromWasm0(r0, r1).slice();\n      wasm.__wbindgen_free(r0, r1 * 4);\n      return v0;\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n  /**\n  * @param {number} l\n  * @returns {any}\n  */\n  get_line(l) {\n    const ret = wasm.vtwrapper_get_line(this.ptr, l);\n    return takeObject(ret);\n  }\n  /**\n  * @returns {any}\n  */\n  get_cursor() {\n    const ret = wasm.vtwrapper_get_cursor(this.ptr);\n    return takeObject(ret);\n  }\n}\nasync function load(module, imports) {\n  if (typeof Response === 'function' && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === 'function') {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get('Content-Type') != 'application/wasm') {\n          console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n        } else {\n          throw e;\n        }\n      }\n    }\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n    if (instance instanceof WebAssembly.Instance) {\n      return {\n        instance,\n        module\n      };\n    } else {\n      return instance;\n    }\n  }\n}\nfunction getImports() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbindgen_object_drop_ref = function (arg0) {\n    takeObject(arg0);\n  };\n  imports.wbg.__wbindgen_error_new = function (arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_object_clone_ref = function (arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_number_new = function (arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_bigint_from_u64 = function (arg0) {\n    const ret = BigInt.asUintN(64, arg0);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_string_new = function (arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_set_20cbc34131e76824 = function (arg0, arg1, arg2) {\n    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n  };\n  imports.wbg.__wbg_new_b525de17f44a8943 = function () {\n    const ret = new Array();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_new_f841cc6f2098f4b5 = function () {\n    const ret = new Map();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_new_f9876326328f45ed = function () {\n    const ret = new Object();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_is_string = function (arg0) {\n    const ret = typeof getObject(arg0) === 'string';\n    return ret;\n  };\n  imports.wbg.__wbg_set_17224bc548dd1d7b = function (arg0, arg1, arg2) {\n    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n  };\n  imports.wbg.__wbg_set_388c4c6422704173 = function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_debug_string = function (arg0, arg1) {\n    const ret = debugString(getObject(arg1));\n    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n  };\n  imports.wbg.__wbindgen_throw = function (arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n  return imports;\n}\nfunction finalizeInit(instance, module) {\n  wasm = instance.exports;\n  init.__wbindgen_wasm_module = module;\n  cachedInt32Memory0 = null;\n  cachedUint32Memory0 = null;\n  cachedUint8Memory0 = null;\n  return wasm;\n}\nfunction initSync(module) {\n  const imports = getImports();\n  if (!(module instanceof WebAssembly.Module)) {\n    module = new WebAssembly.Module(module);\n  }\n  const instance = new WebAssembly.Instance(module, imports);\n  return finalizeInit(instance, module);\n}\nasync function init(input) {\n  const imports = getImports();\n  if (typeof input === 'string' || typeof Request === 'function' && input instanceof Request || typeof URL === 'function' && input instanceof URL) {\n    input = fetch(input);\n  }\n  const {\n    instance,\n    module\n  } = await load(await input, imports);\n  return finalizeInit(instance, module);\n}\n\nvar exports = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  VtWrapper: VtWrapper,\n  create: create$1,\n  default: init,\n  initSync: initSync\n});\n\nconst base64codes = [62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0,0,0,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];\n\n        function getBase64Code(charCode) {\n            return base64codes[charCode - 43];\n        }\n\n        function base64_decode(str) {\n            let missingOctets = str.endsWith(\"==\") ? 2 : str.endsWith(\"=\") ? 1 : 0;\n            let n = str.length;\n            let result = new Uint8Array(3 * (n / 4));\n            let buffer;\n\n            for (let i = 0, j = 0; i < n; i += 4, j += 3) {\n                buffer =\n                    getBase64Code(str.charCodeAt(i)) << 18 |\n                    getBase64Code(str.charCodeAt(i + 1)) << 12 |\n                    getBase64Code(str.charCodeAt(i + 2)) << 6 |\n                    getBase64Code(str.charCodeAt(i + 3));\n                result[j] = buffer >> 16;\n                result[j + 1] = (buffer >> 8) & 0xFF;\n                result[j + 2] = buffer & 0xFF;\n            }\n\n            return result.subarray(0, result.length - missingOctets);\n        }\n\n        const wasm_code = base64_decode(\"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wIHBACABQf8fIAFB/x9LGzYCACADIARPDQBBuIHBAEF/NgIACw8LIABBeHFBkP/AAGohAgJ/QZiBwQAoAgAiA0EBIABBA3Z0IgBxRQRAQZiBwQAgACADcjYCACACDAELIAIoAggLIQAgAiABNgIIIAAgATYCDCABIAI2AgwgASAANgIIDwtBqIHBACABNgIAQaCBwQBBoIHBACgCACAAaiIANgIAIAEgAEEBcjYCBCAAIAFqIAA2AgALlgUBC38jAEEwayIDJAAgA0EkaiABNgIAIANBAzoALCADQSA2AhwgA0EANgIoIAMgADYCICADQQA2AhQgA0EANgIMAn8CQAJAAkAgAigCECILRQRAIAJBDGooAgAiAEUNASACKAIIIgEgAEEDdGohBCAAQQFrQf////8BcUEBaiEIIAIoAgAhAANAIABBBGooAgAiBgRAIAMoAiAgACgCACAGIAMoAiQoAgwRAQANBAsgASgCACADQQxqIAFBBGooAgARAAANAyAFQQFqIQUgAEEIaiEAIAQgAUEIaiIBRw0ACwwBCyACQRRqKAIAIgBFDQAgAEEFdCEMIABBAWtB////P3FBAWohCCACKAIIIQYgAigCACEAA0AgAEEEaigCACIBBEAgAygCICAAKAIAIAEgAygCJCgCDBEBAA0DCyADIAUgC2oiAUEQaigCADYCHCADIAFBHGotAAA6ACwgAyABQRhqKAIANgIoIAFBDGooAgAhB0EAIQpBACEEAkACQAJAIAFBCGooAgBBAWsOAgACAQsgBiAHQQN0aiINKAIEQesARw0BIA0oAgAoAgAhBwtBASEECyADIAc2AhAgAyAENgIMIAFBBGooAgAhBAJAAkACQCABKAIAQQFrDgIAAgELIAYgBEEDdGoiBygCBEHrAEcNASAHKAIAKAIAIQQLQQEhCgsgAyAENgIYIAMgCjYCFCAGIAFBFGooAgBBA3RqIgEoAgAgA0EMaiABQQRqKAIAEQAADQIgCUEBaiEJIABBCGohACAMIAVBIGoiBUcNAAsLIAggAigCBE8NASADKAIgIAIoAgAgCEEDdGoiACgCACAAKAIEIAMoAiQoAgwRAQBFDQELQQEMAQtBAAsgA0EwaiQAC90LAg5/AX4jAEFAaiIDJAAgAUEUaigCACEMIAEoAiQhCSABKAIQIQcgA0EwaiENIANB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AiEEDAILIAMgBGoiAEEBaiEEAkAgACACTw0AIAAgAWotAABBCkcNAEEAIQUgBCIDIQAMAwsgAiAETw0ACwtBASEFIAIiACAIIgNGDQILAkAgDC0AAARAIAtBsObAAEEEIAooAgwRAQANAQsgASAIaiEGIAAgCGshB0EAIQkgDCAAIAhHBH8gBiAHakEBay0AAEEKRgVBAAs6AAAgAyEIIAsgBiAHIAooAgwRAQBFDQELC0EBIQ0LIA0L1AYBBX8jAEHAAWsiAiQAIAAoAgAhAyACQQRqIgBBtAFqQZCHwAA2AgAgAkGwAWpBoIvAADYCACAAQaQBakHAi8AANgIAIABBnAFqQbCLwAA2AgAgAEGUAWpBsIvAADYCACACQZABakHQhsAANgIAIAJBiAFqQdCGwAA2AgAgAkGAAWpBoIvAADYCACACQfgAakGgi8AANgIAIABB7ABqQaCLwAA2AgAgAkHoAGpBoIvAADYCACACQeAAakGgi8AANgIAIABB1ABqQZCLwAA2AgAgAkHQAGpB0IbAADYCACACQcgAakGAi8AANgIAIAJBQGtB8IrAADYCACACQThqQeCKwAA2AgAgAkEwakH0hsAANgIAIAJBKGpB0IrAADYCACACQSBqQcCKwAA2AgAgAkEYakHAisAANgIAIAJBEGpB0IbAADYCACACIANBugFqNgKsASACIANB1ABqNgKkASACIANBgAFqNgKcASACIANB7ABqNgKUASACIANBpAFqNgKMASACIANBoAFqNgKEASACIANBuQFqNgJ8IAIgA0G4AWo2AnQgAiADQbcBajYCbCACIANBtgFqNgJkIAIgA0G1AWo2AlwgAiADQcgAajYCVCACIANBnAFqNgJMIAIgA0GoAWo2AkQgAiADQaoBajYCPCACIANB4ABqNgI0IAIgA0FAazYCLCACIANBtAFqNgIkIAIgA0EgajYCHCACIAM2AhQgAiADQZgBajYCDCACQdCGwAA2AgggAiADQZQBajYCBCACIANBuwFqNgK8ASACIAJBvAFqNgK0AUEXIQZBiInAACEEIwBBIGsiAyQAIANBFzYCACADQRc2AgQgASgCFEHQi8AAQQggAUEYaigCACgCDBEBACEFIANBADoADSADIAU6AAwgAyABNgIIAn8DQCADQQhqIAQoAgAgBEEEaigCACAAQdDowAAQICEFIABBCGohACAEQQhqIQQgBkEBayIGDQALIAMtAAwhASABQQBHIAMtAA1FDQAaQQEgAQ0AGiAFKAIAIgAtABxBBHFFBEAgACgCFEG/5sAAQQIgACgCGCgCDBEBAAwBCyAAKAIUQb7mwABBASAAKAIYKAIMEQEACyADQSBqJAAgAkHAAWokAAv1AwEEfyMAQRBrIgMkAAJAAkAgACgCnAEiAkEBTQRAAkAgACACakGoAWotAABFDQAgAUHgAGsiAkEeSw0AIAJBAnRBtKXAAGooAgAhAQsgA0EMaiAAQbIBai8BADsBACADIAE2AgAgAyAAKQGqATcCBCAALQC3AUUNAiAALQC5AUUNAiAAQQA6ALkBIABBADYCYCAAQeQAaigCACIBIAAoAqQBRg0BIAEgACgCmAFBAWtPDQIgACABQaScwAAQfUEBOgAMIABBADoAuQEgACAAKAJkQQFqNgJkIAAgACgCYCIBIAAoApQBQQFrIgIgASACSRs2AmAMAgsgAkECQYykwAAQWQALIAAgAUGknMAAEH1BAToADCAAQQEQnwELAkAgAAJ/IAAoAmAiAkEBaiIBIAAoApQBIgRJBEAgAEHkAGooAgAhBAJAIAAtALUBRQRAIAAgAiAEIAMQgQEMAQsgACgCFCEFIAAgBEG0nMAAEH0gAiACIAVHIAMQQQtBAAwBCyAAIARBAWsgAEHkAGooAgAgAxCBASAALQC3AUUNASAAKAKUASEBQQELOgC5ASAAIAE2AmALIABB3ABqKAIAIgIgAEHkAGooAgAiAUsEQCAAQdgAaigCACABakEBOgAAIANBEGokAA8LIAEgAkHQqcAAEFkAC/gDAQJ/IAAgAWohAgJAAkAgACgCBCIDQQFxDQAgA0EDcUUNASAAKAIAIgMgAWohASAAIANrIgBBqIHBACgCAEYEQCACKAIEQQNxQQNHDQFBoIHBACABNgIAIAIgAigCBEF+cTYCBCAAIAFBAXI2AgQgAiABNgIADwsgACADEB8LAkACQAJAIAIoAgQiA0ECcUUEQCACQayBwQAoAgBGDQIgAkGogcEAKAIARg0DIAIgA0F4cSICEB8gACABIAJqIgFBAXI2AgQgACABaiABNgIAIABBqIHBACgCAEcNAUGggcEAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQJAwDCyABQXhxQZD/wABqIQICf0GYgcEAKAIAIgNBASABQQN2dCIBcUUEQEGYgcEAIAEgA3I2AgAgAgwBCyACKAIICyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCA8LQayBwQAgADYCAEGkgcEAQaSBwQAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEGogcEAKAIARw0BQaCBwQBBADYCAEGogcEAQQA2AgAPC0GogcEAIAA2AgBBoIHBAEGggcEAKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsL5wIBBX8CQEHN/3sgAEEQIABBEEsbIgBrIAFNDQBBECABQQtqQXhxIAFBC0kbIgQgAGpBDGoQDyICRQ0AIAJBCGshAQJAIABBAWsiAyACcUUEQCABIQAMAQsgAkEEayIFKAIAIgZBeHFBACAAIAIgA2pBACAAa3FBCGsiACABa0EQSxsgAGoiACABayICayEDIAZBA3EEQCAAIAMgACgCBEEBcXJBAnI2AgQgACADaiIDIAMoAgRBAXI2AgQgBSACIAUoAgBBAXFyQQJyNgIAIAEgAmoiAyADKAIEQQFyNgIEIAEgAhAbDAELIAEoAgAhASAAIAM2AgQgACABIAJqNgIACwJAIAAoAgQiAUEDcUUNACABQXhxIgIgBEEQak0NACAAIAQgAUEBcXJBAnI2AgQgACAEaiIBIAIgBGsiBEEDcjYCBCAAIAJqIgIgAigCBEEBcjYCBCABIAQQGwsgAEEIaiEDCyADC44DAQd/IwBBEGsiBCQAAkACQAJAAkACQAJAIAEoAgQiAkUNACABKAIAIQUgAkEDcSEGAkAgAkEESQRAQQAhAgwBCyAFQRxqIQMgAkF8cSEIQQAhAgNAIAMoAgAgA0EIaygCACADQRBrKAIAIANBGGsoAgAgAmpqamohAiADQSBqIQMgCCAHQQRqIgdHDQALCyAGBEAgB0EDdCAFakEEaiEDA0AgAygCACACaiECIANBCGohAyAGQQFrIgYNAAsLIAFBDGooAgAEQCACQQBIDQEgBSgCBEUgAkEQSXENASACQQF0IQILIAINAQtBASEDQQAhAgwBCyACQQBIDQFBrf3AAC0AABogAkEBEMkBIgNFDQILIARBADYCCCAEIAM2AgQgBCACNgIAIARBuODAACABEBZFDQJBmOHAAEEzIARBD2pBzOHAAEH04cAAEE4ACxCSAQALQQEgAkHo/cAAKAIAIgBB1gAgABsRAgAACyAAIAQpAgA3AgAgAEEIaiAEQQhqKAIANgIAIARBEGokAAvaAgEHf0EBIQkCQAJAIAJFDQAgASACQQF0aiEKIABBgP4DcUEIdiELIABB/wFxIQ0DQCABQQJqIQwgByABLQABIgJqIQggCyABLQAAIgFHBEAgASALSw0CIAghByAKIAwiAUYNAgwBCwJAAkAgByAITQRAIAQgCEkNASADIAdqIQEDQCACRQ0DIAJBAWshAiABLQAAIAFBAWohASANRw0AC0EAIQkMBQsgByAIQbzqwAAQWwALIAggBEG86sAAEFoACyAIIQcgCiAMIgFHDQALCyAGRQ0AIAUgBmohAyAAQf//A3EhAQNAIAVBAWohAAJAIAUtAAAiAsAiBEEATgRAIAAhBQwBCyAAIANHBEAgBS0AASAEQf8AcUEIdHIhAiAFQQJqIQUMAQtBp+PAAEErQazqwAAQiwEACyABIAJrIgFBAEgNASAJQQFzIQkgAyAFRw0ACwsgCUEBcQv9AgEEfyAAKAIMIQICQAJAIAFBgAJPBEAgACgCGCEEAkACQCAAIAJGBEAgAEEUQRAgAEEUaiICKAIAIgMbaigCACIBDQFBACECDAILIAAoAggiASACNgIMIAIgATYCCAwBCyACIABBEGogAxshAwNAIAMhBSABIgJBFGoiAygCACEBIAMgAkEQaiABGyEDIAJBFEEQIAEbaigCACIBDQALIAVBADYCAAsgBEUNAiAAIAAoAhxBAnRBgP7AAGoiASgCAEcEQCAEQRBBFCAEKAIQIABGG2ogAjYCACACRQ0DDAILIAEgAjYCACACDQFBnIHBAEGcgcEAKAIAQX4gACgCHHdxNgIADAILIAIgACgCCCIARwRAIAAgAjYCDCACIAA2AggPC0GYgcEAQZiBwQAoAgBBfiABQQN2d3E2AgAPCyACIAQ2AhggACgCECIBBEAgAiABNgIQIAEgAjYCGAsgAEEUaigCACIARQ0AIAJBFGogADYCACAAIAI2AhgLC4oDAgV/AX4jAEFAaiIFJABBASEHAkAgAC0ABA0AIAAtAAUhCCAAKAIAIgYoAhwiCUEEcUUEQCAGKAIUQbfmwABBtObAACAIG0ECQQMgCBsgBkEYaigCACgCDBEBAA0BIAYoAhQgASACIAYoAhgoAgwRAQANASAGKAIUQYTmwABBAiAGKAIYKAIMEQEADQEgAyAGIAQoAgwRAAAhBwwBCyAIRQRAIAYoAhRBuebAAEEDIAZBGGooAgAoAgwRAQANASAGKAIcIQkLIAVBAToAGyAFQTRqQZjmwAA2AgAgBSAGKQIUNwIMIAUgBUEbajYCFCAFIAYpAgg3AiQgBikCACEKIAUgCTYCOCAFIAYoAhA2AiwgBSAGLQAgOgA8IAUgCjcCHCAFIAVBDGoiBjYCMCAGIAEgAhAYDQAgBUEMakGE5sAAQQIQGA0AIAMgBUEcaiAEKAIMEQAADQAgBSgCMEG85sAAQQIgBSgCNCgCDBEBACEHCyAAQQE6AAUgACAHOgAEIAVBQGskACAAC/IDAQd/IwBBMGsiBSQAIAIgAWsiBiADSyEHIAJBAWsiCCAAKAIYQQFrSQRAIAAgCEG0ncAAEH1BADoADAsgAyAGIAcbIQMCQAJAIAFFBEAgACgCGCIBIAJGDQEgBUEQaiAAKAIUIAQQTCADBEAgAEEQaigCACACIAFraiECIABBCGohBCAFKAIYIgdBBHQhCSAFLQAcIQogBSgCFCELA0AgBSAHEFwgBSgCACEBIAUoAgQgCyAJEO8BIQYgBSAKOgAsIAUgBzYCKCAFIAY2AiQgBSABNgIgIAVBIGohCCAEKAIIIgEgBCgCAEYEQCAEIAFBARB8CyAEKAIEIAJBBHRqIQYCQCABIAJNBEAgASACRg0BIAIgARBXAAsgBkEQaiAGIAEgAmtBBHQQ7QELIAYgCCkCADcCACAEIAFBAWo2AgggBkEIaiAIQQhqKQIANwIAIANBAWsiAw0ACwsgBSgCEEUNAiAFKAIUEBUMAgsgACABQQFrQcSdwAAQfUEAOgAMIAVBCGogACABIAJB1J3AABBdIAUoAgghASAFKAIMIgYgA0kEQEG8n8AAQSNBrKDAABCLAQALIAMgASADQQR0aiAGIANrEBMgACACIANrIAIgBBBTDAELIAAgAyAAKAIUEHMLIABBAToAHCAFQTBqJAALmgQBBX8jAEEQayIDJAACQAJ/AkAgAUGAAU8EQCADQQA2AgwgAUGAEEkNASABQYCABEkEQCADIAFBP3FBgAFyOgAOIAMgAUEMdkHgAXI6AAwgAyABQQZ2QT9xQYABcjoADUEDDAMLIAMgAUE/cUGAAXI6AA8gAyABQQZ2QT9xQYABcjoADiADIAFBDHZBP3FBgAFyOgANIAMgAUESdkEHcUHwAXI6AAxBBAwCCyAAKAIIIgIgACgCAEYEQCMAQSBrIgQkAAJAAkAgAkEBaiICRQ0AIAAoAgAiBkEBdCIFIAIgAiAFSRsiAkEIIAJBCEsbIgVBf3NBH3YhAgJAIAZFBEAgBEEANgIYDAELIAQgBjYCHCAEQQE2AhggBCAAKAIENgIUCyAEQQhqIAIgBSAEQRRqED0gBCgCDCECIAQoAghFBEAgACAFNgIAIAAgAjYCBAwCCyACQYGAgIB4Rg0BIAJFDQAgAiAEQRBqKAIAQej9wAAoAgAiAEHWACAAGxECAAALEJIBAAsgBEEgaiQAIAAoAgghAgsgACACQQFqNgIIIAAoAgQgAmogAToAAAwCCyADIAFBP3FBgAFyOgANIAMgAUEGdkHAAXI6AAxBAgshASABIAAoAgAgACgCCCICa0sEQCAAIAIgARA4IAAoAgghAgsgACgCBCACaiADQQxqIAEQ7wEaIAAgASACajYCCAsgA0EQaiQAQQALwAICBX8BfiMAQTBrIgQkAEEnIQICQCAAQpDOAFQEQCAAIQcMAQsDQCAEQQlqIAJqIgNBBGsgACAAQpDOAIAiB0KQzgB+faciBUH//wNxQeQAbiIGQQF0QfbmwABqLwAAOwAAIANBAmsgBSAGQeQAbGtB//8DcUEBdEH25sAAai8AADsAACACQQRrIQIgAEL/wdcvViAHIQANAAsLIAenIgNB4wBLBEAgB6ciBUH//wNxQeQAbiEDIAJBAmsiAiAEQQlqaiAFIANB5ABsa0H//wNxQQF0QfbmwABqLwAAOwAACwJAIANBCk8EQCACQQJrIgIgBEEJamogA0EBdEH25sAAai8AADsAAAwBCyACQQFrIgIgBEEJamogA0EwajoAAAsgAUGM48AAQQAgBEEJaiACakEnIAJrEBQgBEEwaiQAC7YCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEGIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiAjYCHCACQQJ0QYD+wABqIQQCQEGcgcEAKAIAIgVBASACdCIDcUUEQEGcgcEAIAMgBXI2AgAgBCAANgIAIAAgBDYCGAwBCwJAAkAgASAEKAIAIgMoAgRBeHFGBEAgAyECDAELIAFBAEEZIAJBAXZrIAJBH0YbdCEEA0AgAyAEQR12QQRxakEQaiIFKAIAIgJFDQIgBEEBdCEEIAIhAyACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEANgIYIAAgAjYCDCAAIAE2AggPCyAFIAA2AgAgACADNgIYCyAAIAA2AgwgACAANgIIC58NAQp/IwBBEGsiAiQAQQEhCwJAAkAgASgCFCIJQScgAUEYaigCACgCECIKEQAADQAgACgCACEDIwBBEGsiBCQAAkACQAJAAkACQAJAAkACQAJAIAMOKAUHBwcHBwcHBwEDBwcCBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwYACyADQdwARg0DDAYLIAJBgAQ7AQogAkIANwECIAJB3OgBOwEADAYLIAJBgAQ7AQogAkIANwECIAJB3OQBOwEADAULIAJBgAQ7AQogAkIANwECIAJB3NwBOwEADAQLIAJBgAQ7AQogAkIANwECIAJB3LgBOwEADAMLIAJBgAQ7AQogAkIANwECIAJB3OAAOwEADAILIAJBgAQ7AQogAkIANwECIAJB3M4AOwEADAELIANBC3QhBUEhIQBBISEHAkADQCAAQQF2IAZqIgFBAnRB0PbAAGooAgBBC3QiACAFRwRAIAEgByAAIAVLGyIHIAFBAWogBiAAIAVJGyIGayEAIAYgB0kNAQwCCwsgAUEBaiEGCwJ/An8CQCAGQSBNBEAgBkECdCIAQdD2wABqKAIAQRV2IQEgBkEgRw0BQdcFIQdBHwwCCyAGQSFB8PXAABBZAAsgAEHU9sAAaigCAEEVdiEHQQAgBkUNARogBkEBawtBAnRB0PbAAGooAgBB////AHELIQACQAJAAkAgByABQX9zakUNACADIABrIQUgAUHXBSABQdcFSxshCCAHQQFrIQBBACEGA0AgASAIRg0CIAUgBiABQdT3wABqLQAAaiIGSQ0BIAAgAUEBaiIBRw0ACyAAIQELIAFBAXEhAAwBCyAIQdcFQYD2wAAQWQALAkACQAJAIABFBEACfwJAIANBIEkNAAJAAn9BASADQf8ASQ0AGiADQYCABEkNAQJAIANBgIAITwRAIANBsMcMa0HQuitJDQQgA0HLpgxrQQVJDQQgA0Ge9AtrQeILSQ0EIANB4dcLa0GfGEkNBCADQaKdC2tBDkkNBCADQX5xQZ7wCkYNBCADQWBxQeDNCkcNAQwECyADQczqwABBLEGk68AAQcQBQejswABBwgMQHgwEC0EAIANBuu4Ka0EGSQ0AGiADQYCAxABrQfCDdEkLDAILIANBqvDAAEEoQfrwwABBnwJBmfPAAEGvAhAeDAELQQALRQ0BIAIgAzYCBCACQYABOgAADAQLIARBCGpBADoAACAEQQA7AQYgBEH9ADoADyAEIANBD3FB0+PAAGotAAA6AA4gBCADQQR2QQ9xQdPjwABqLQAAOgANIAQgA0EIdkEPcUHT48AAai0AADoADCAEIANBDHZBD3FB0+PAAGotAAA6AAsgBCADQRB2QQ9xQdPjwABqLQAAOgAKIAQgA0EUdkEPcUHT48AAai0AADoACSADQQFyZ0ECdkECayIFQQtPDQEgBEEGaiIBIAVqIgBBvPbAAC8AADsAACAAQQJqQb72wAAtAAA6AAAgAiAEKQEGNwAAIAJBCGogAUEIai8BADsAACACQQo6AAsgAiAFOgAKDAMLIARBCGpBADoAACAEQQA7AQYgBEH9ADoADyAEIANBD3FB0+PAAGotAAA6AA4gBCADQQR2QQ9xQdPjwABqLQAAOgANIAQgA0EIdkEPcUHT48AAai0AADoADCAEIANBDHZBD3FB0+PAAGotAAA6AAsgBCADQRB2QQ9xQdPjwABqLQAAOgAKIAQgA0EUdkEPcUHT48AAai0AADoACSADQQFyZ0ECdkECayIFQQtPDQEgBEEGaiIBIAVqIgBBvPbAAC8AADsAACAAQQJqQb72wAAtAAA6AAAgAiAEKQEGNwAAIAJBCGogAUEIai8BADsAACACQQo6AAsgAiAFOgAKDAILIAVBCkGs9sAAEFgACyAFQQpBrPbAABBYAAsgBEEQaiQAAkAgAi0AAEGAAUYEQCACQQhqIQVBgAEhCANAAkAgCEGAAUcEQCACLQAKIgAgAi0AC08NBCACIABBAWo6AAogAEEKTw0GIAAgAmotAAAhAQwBC0EAIQggBUEANgIAIAIoAgQhASACQgA3AwALIAkgASAKEQAARQ0ACwwCCyACLQAKIgFBCiABQQpLGyEAIAItAAsiBSABIAEgBUkbIQcDQCABIAdGDQEgAiABQQFqIgU6AAogACABRg0DIAEgAmohCCAFIQEgCSAILQAAIAoRAABFDQALDAELIAlBJyAKEQAAIQsLIAJBEGokACALDwsgAEEKQcD2wAAQWQALoAQBA38CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCGsOCAECAwQFDQYHAAsgAUGEAWsOCgcICwsJCwsLCwoLCyAALQC5ASEBIABBADoAuQEgAEEAIAAoAmBBfkF/IAEbaiIBIAAoApQBIgBBAWsgACABSxsgAUEASBs2AmAPCyAAQdAAaigCAEECdCEBIABBzABqKAIAIQIgACgCYCEEAkACQANAIAFFDQEgAUEEayEBIAIoAgAhAyACQQRqIQIgAyAETQ0ACyAAKAKUASIBQQFrIQIMAQsgACgClAEiAUEBayICIQMLIABBADoAuQEgACADIAIgASADSxs2AmAPCyAAEGogAC0AuAFFDQgMCQsgABBqIAAtALgBRQ0HDAgLIAAQaiAALQC4AUUNBgwHCyAAQQE2ApwBDwsgAEEANgKcAQ8LIAAQaiAALQC4AUUNAwwECyAAEGoMAwsgACgCYCIBRQ0BIAEgACgClAFPDQEgAEHIAGogARBRDwsCQCAAQeQAaigCACIBIAAoAqABIgJHBEAgAQRAIABBADoAuQEgACAAKAJgIgMgACgClAFBAWsiBCADIARJGzYCYCAAIAEgAkEAIAAtALYBIgIbIgFqQQFrIgMgASABIANJGyIBIAAoAqQBIAAoApgBQQFrIAIbIgAgACABSxs2AmQLDAELIABBARCgAQsLDwsgAEEAOgC5ASAAQQA2AmALxgIAAkACQAJAAkACQAJAAkAgA0EBaw4GAAECAwQFBgsgACgCFCEDIAAgAkHknMAAEH0iBEEAOgAMIAQgASADIAUQSCAAIAJBAWogACgCGCAFEFMPCyAAKAIUIQMgACACQfScwAAQfUEAIAFBAWoiASADIAEgA0kbIAUQSCAAQQAgAiAFEFMPCyAAQQAgACgCGCAFEFMPCyAAKAIUIQMgACACQYSdwAAQfSIAIAEgAyAFEEggAEEAOgAMDwsgACgCFCEDIAAgAkGUncAAEH1BACABQQFqIgAgAyAAIANJGyAFEEgPCyAAKAIUIQEgACACQaSdwAAQfSIAQQAgASAFEEggAEEAOgAMDwsgACgCFCEDIAAgAkHUnMAAEH0iACABIAEgBCADIAFrIgEgASAESxtqIgEgBRBIIAEgA0YEQCAAQQA6AAwLC6ACAQJ/IwBBEGsiAiQAAkACfwJAIAFBgAFPBEAgAkEANgIMIAFBgBBJDQEgAUGAgARJBEAgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwwDCyACIAFBP3FBgAFyOgAPIAIgAUEGdkE/cUGAAXI6AA4gAiABQQx2QT9xQYABcjoADSACIAFBEnZBB3FB8AFyOgAMQQQMAgsgACgCCCIDIAAoAgBGBH8gACADEHkgACgCCAUgAwsgACgCBGogAToAACAAIAAoAghBAWo2AggMAgsgAiABQT9xQYABcjoADSACIAFBBnZBwAFyOgAMQQILIQEgACACQQxqIgAgACABahCDAQsgAkEQaiQAQQALxwICBH8BfiMAQUBqIgMkAEEBIQUCQCAALQAEDQAgAC0ABSEFAkAgACgCACIEKAIcIgZBBHFFBEAgBUUNAUEBIQUgBCgCFEG35sAAQQIgBEEYaigCACgCDBEBAEUNAQwCCyAFRQRAQQEhBSAEKAIUQcXmwABBASAEQRhqKAIAKAIMEQEADQIgBCgCHCEGC0EBIQUgA0EBOgAbIANBNGpBmObAADYCACADIAQpAhQ3AgwgAyADQRtqNgIUIAMgBCkCCDcCJCAEKQIAIQcgAyAGNgI4IAMgBCgCEDYCLCADIAQtACA6ADwgAyAHNwIcIAMgA0EMajYCMCABIANBHGogAigCDBEAAA0BIAMoAjBBvObAAEECIAMoAjQoAgwRAQAhBQwBCyABIAQgAigCDBEAACEFCyAAQQE6AAUgACAFOgAEIANBQGskAAvEAgIEfwF+IwBBQGoiAyQAIAAoAgAhBSAAAn9BASAALQAIDQAaIAAoAgQiBCgCHCIGQQRxRQRAQQEgBCgCFEG35sAAQcHmwAAgBRtBAkEBIAUbIARBGGooAgAoAgwRAQANARogASAEIAIoAgwRAAAMAQsgBUUEQEEBIAQoAhRBwubAAEECIARBGGooAgAoAgwRAQANARogBCgCHCEGCyADQQE6ABsgA0E0akGY5sAANgIAIAMgBCkCFDcCDCADIANBG2o2AhQgAyAEKQIINwIkIAQpAgAhByADIAY2AjggAyAEKAIQNgIsIAMgBC0AIDoAPCADIAc3AhwgAyADQQxqNgIwQQEgASADQRxqIAIoAgwRAAANABogAygCMEG85sAAQQIgAygCNCgCDBEBAAs6AAggACAFQQFqNgIAIANBQGskACAAC5cCAQJ/IwBBEGsiAiQAAkAgACACQQxqAn8CQCABQYABTwRAIAJBADYCDCABQYAQSQ0BIAFBgIAESQRAIAIgAUE/cUGAAXI6AA4gAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMMAwsgAiABQT9xQYABcjoADyACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA0gAiABQRJ2QQdxQfABcjoADEEEDAILIAAoAggiAyAAKAIARgR/IAAgAxB5IAAoAggFIAMLIAAoAgRqIAE6AAAgACAAKAIIQQFqNgIIDAILIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECCxDMAQsgAkEQaiQAQQALpAIBBn8jAEEQayICJAACQAJAIAEoAhAiBSAAKAIAIAAoAggiA2tLBEAgACADIAUQfCAAKAIEIQQgACgCCCEDIAJBCGogAUEMaigCADYCACACIAEpAgQ3AwAMAQsgACgCBCEEIAJBCGogAUEMaigCADYCACACIAEpAgQ3AwAgBUUNAQsCQCABKAIAIgZBgIDEAEYNACAEIANBBHRqIgEgBjYCACABIAIpAwA3AgQgAUEMaiACQQhqIgcoAgA2AgAgBUEBayIERQRAIANBAWohAwwBCyADIAVqIQMgAUEUaiEBA0AgAUEEayAGNgIAIAEgAikDADcCACABQQhqIAcoAgA2AgAgAUEQaiEBIARBAWsiBA0ACwsgACADNgIICyACQRBqJAALiAQBDX8jAEHQAGsiBiQAIAZBADsAHiAGQQI6ABogBkECOgAWIAZBQGsiB0EIaiILIAUgBkEWaiAFGyIFQQhqLwAAOwEAIAYgBSkAADcDQCAGQTBqIgUgASAHEEwgBkEIaiACEFwgC0EANgIAIAYgBikDCDcCQCMAQRBrIgokACACIAcoAgAgBygCCCIIa0sEQCAHIAggAhB8IAcoAgghCAsgBygCBCAIQQR0aiEJIAJBAk8EQCACQQFrIQwgBSgCCCINQQR0IQ4gBS0ADCEPIAUoAgQhEANAIApBCGogDRBcIAooAgghESAKKAIMIBAgDhDvASESIAkgDzoADCAJIA02AgggCSASNgIEIAkgETYCACAJQRBqIQkgDEEBayIMDQALIAIgCGpBAWshCAsCQCACBEAgCSAFKQIANwIAIAcgCEEBajYCCCAJQQhqIAVBCGopAgA3AgAMAQsgByAINgIIIAUoAgBFDQAgBSgCBBAVCyAKQRBqJAAgBkEoaiALKAIANgIAIAYgBikCQDcDIEHoByEFAkAgA0EBRgRAIAQiBUUNAQsgBigCICAGKAIoIgdrIAVPDQAgBkEgaiAHIAUQfAsgACAGKQMgNwIIIAAgAjYCGCAAIAE2AhQgAEEAOgAcIAAgBDYCBCAAIAM2AgAgAEEQaiAGQShqKAIANgIAIAZB0ABqJAAL8gEBBH8gACgCBCECIABB8KnAADYCBCAAKAIAIQEgAEHwqcAANgIAIAAoAgghAwJAAkAgASACRgRAIAAoAhAiAUUNASAAKAIMIgIgAygCCCIARg0CIAMoAgQiBCAAQQR0aiAEIAJBBHRqIAFBBHQQ7QEMAgsgAiABa0EEdiECA0AgASgCAARAIAFBBGooAgAQFQsgAUEQaiEBIAJBAWsiAg0ACyAAKAIQIgFFDQAgACgCDCICIAMoAggiAEcEQCADKAIEIgQgAEEEdGogBCACQQR0aiABQQR0EO0BCyADIAAgAWo2AggLDwsgAyAAIAFqNgIIC4oCAgR/AX4jAEEwayICJAAgASgCAEGAgICAeEYEQCABKAIMIQMgAkEkaiIEQQhqIgVBADYCACACQoCAgIAQNwIkIARBzN3AACADEBYaIAJBIGogBSgCACIDNgIAIAIgAikCJCIGNwMYIAFBCGogAzYCACABIAY3AgALIAEpAgAhBiABQoCAgIAQNwIAIAJBEGoiAyABQQhqIgEoAgA2AgAgAUEANgIAQa39wAAtAAAaIAIgBjcDCEEMQQQQyQEiAUUEQEEEQQxB6P3AACgCACIAQdYAIAAbEQIAAAsgASACKQMINwIAIAFBCGogAygCADYCACAAQfjewAA2AgQgACABNgIAIAJBMGokAAvfAQEBfyMAQRBrIhUkACAAKAIUIAEgAiAAQRhqKAIAKAIMEQEAIQEgFUEAOgANIBUgAToADCAVIAA2AgggFUEIaiADIAQgBSAGECAgByAIIAlB0IbAABAgIAogCyAMIA0QICAOIA8gECARECAgEiATIBRBkIfAABAgIQECfyAVLQAMIgJBAEcgFS0ADUUNABpBASACDQAaIAEoAgAiAC0AHEEEcUUEQCAAKAIUQb/mwABBAiAAKAIYKAIMEQEADAELIAAoAhRBvubAAEEBIAAoAhgoAgwRAQALIBVBEGokAAvSAQEEfyMAQSBrIgMkAAJAIAIgAkEBaiICSw0AIAEoAgAiBEEBdCIFIAIgAiAFSRsiAkEEIAJBBEsbIgJBAnQhBSACQYCAgIACSUECdCEGAkAgBEUEQCADQQA2AhgMAQsgA0EENgIYIAMgBEECdDYCHCADIAEoAgQ2AhQLIANBCGogBiAFIANBFGoQPCADKAIMIQQgAygCCARAIANBEGooAgAhAgwBCyABIAI2AgAgASAENgIEQYGAgIB4IQQLIAAgAjYCBCAAIAQ2AgAgA0EgaiQAC80BAAJAAkAgAQRAIAJBAEgNAQJAAkACfyADKAIEBEAgA0EIaigCACIBRQRAIAJFBEBBASEBDAQLQa39wAAtAAAaIAJBARDJAQwCCyADKAIAIAFBASACEL8BDAELIAJFBEBBASEBDAILQa39wAAtAAAaIAJBARDJAQsiAUUNAQsgACABNgIEIABBCGogAjYCACAAQQA2AgAPCyAAQQE2AgQMAgsgAEEANgIEDAELIABBADYCBCAAQQE2AgAPCyAAQQhqIAI2AgAgAEEBNgIAC9ABAQF/IwBBEGsiBSQAIAUgACgCFCABIAIgAEEYaigCACgCDBEBADoADCAFIAA2AgggBSACRToADSAFQQA2AgQgBUEEaiADIAQQKiEAIAUtAAwhAQJ/IAFBAEcgACgCACICRQ0AGkEBIAENABogBSgCCCEBAkAgAkEBRw0AIAUtAA1FDQAgAS0AHEEEcQ0AQQEgASgCFEHE5sAAQQEgAUEYaigCACgCDBEBAA0BGgsgASgCFEHS48AAQQEgAUEYaigCACgCDBEBAAsgBUEQaiQAC4QCAQJ/IwBBIGsiBiQAQfz9wABB/P3AACgCACIHQQFqNgIAAkACQCAHQQBIDQBByIHBAC0AAA0AQciBwQBBAToAAEHEgcEAQcSBwQAoAgBBAWo2AgAgBiAFOgAdIAYgBDoAHCAGIAM2AhggBiACNgIUIAZBwN/AADYCECAGQaDdwAA2AgxB7P3AACgCACICQQBIDQBB7P3AACACQQFqNgIAQez9wABB9P3AACgCAAR/IAYgACABKAIQEQIAIAYgBikDADcCDEH0/cAAKAIAIAZBDGpB+P3AACgCACgCFBECAEHs/cAAKAIAQQFrBSACCzYCAEHIgcEAQQA6AAAgBA0BCwALAAvPAQEBfyMAQRBrIg4kACAAKAIUIAFBAyAAQRhqKAIAKAIMEQEAIQEgDkEAOgANIA4gAToADCAOIAA2AgggDkEIaiACQQogAyAEECAgBUEKIAYgBxAgIAhBCSAJIAoQICALQQUgDCANECAhAQJ/IA4tAAwiAkEARyAOLQANRQ0AGkEBIAINABogASgCACIALQAcQQRxRQRAIAAoAhRBv+bAAEECIAAoAhgoAgwRAQAMAQsgACgCFEG+5sAAQQEgACgCGCgCDBEBAAsgDkEQaiQAC6IMAhJ/AX4jAEEQayIQJAAgACgClAEiCCAAKAIURwRAIABBADoAuQELIBBBCGohESAAKAKYASENIAAoAmAhCyAAQeQAaigCACEHIwBBQGoiBiQAQQAgAEEQaigCACICIAAoAhgiCWsgB2oiASACayIEIAEgBEkbIQ4gAEEMaigCACEMIAAoAhQhDwJAIAJFDQAgAUUNACACIAdqIAlBf3NqIQMgDEEMaiEFIAJBBHRBEGshAQNAIAogD2pBACAFLQAAIgQbIQogDiAERWohDiADRQ0BIAVBEGohBSADQQFrIQMgASIEQRBrIQEgBA0ACwsCQCAIIA9GDQAgCiALaiEKIABBADYCECAGQQA2AjggBiACNgI0IAYgAEEIaiIHNgIwIAYgDCACQQR0ajYCLCAGIAw2AiggBiAINgI8IAZBgICAgHg2AhggBkEMaiELIwBBQGoiASQAIAFBGGogBkEYaiIEEBcCQCABKAIYQYCAgIB4RgRAIAtBADYCCCALQoCAgIDAADcCACAEEJ4BDAELIAFBBBBcIAFBGGoiDEEIaikCACETIAEoAgAhBSABKAIEIgMgASkCGDcCACADQQhqIBM3AgAgAUEMaiICQQhqIg9BATYCACABIAM2AhAgASAFNgIMIAwgBEEoEO8BGiMAQRBrIgQkACAEIAwQFyAEKAIAQYCAgIB4RwRAIAIoAggiA0EEdCEFA0AgAigCACADRgRAIAIgA0EBEHwLIAIgA0EBaiIDNgIIIAIoAgQgBWoiEiAEKQIANwIAIBJBCGogBEEIaikCADcCACAEIAwQFyAFQRBqIQUgBCgCAEGAgICAeEcNAAsLIAwQngEgBEEQaiQAIAtBCGogDygCADYCACALIAEpAgw3AgALIAFBQGskACAGKAIUQQR0IQMgBigCECEFAkADQCADRQ0BIANBEGshAyAFKAIIIAVBEGohBSAIRg0AC0H0nsAAQTdBrJ/AABCLAQALIAZBIGoiASAGQRRqKAIANgIAIAYgBikCDDcDGCAHEIABIAcoAgAEQCAAKAIMEBULIAcgBikDGDcCACAHQQhqIAEoAgA2AgAgCSAAKAIQIgJLBEAgACAJIAJrIAgQcyAAKAIQIQILQQAhAwJAIA5FDQAgAkEBayIERQ0AIAAoAgxBDGohBUEAIQEDQAJAIAIgA0cEQCADQQFqIQMgDiABIAUtAABFaiIBSw0BDAMLIAIgAkG0nsAAEFkACyAFQRBqIQUgAyAESQ0ACwsCQAJAIAggCksNACADIAIgAiADSRshASAAKAIMIANBBHRqQQxqIQUDQCABIANGDQIgBS0AAEUNASAFQRBqIQUgA0EBaiEDIAogCGsiCiAITw0ACwsgCiAIQQFrIgEgASAKSxshCyADIAkgAmtqIgFBAE4hBCABQQAgBBshByAJQQAgASAEG2shCQwBCyABIAJBpJ7AABBZAAsCQAJAAkACQAJAQX8gCSANRyAJIA1LG0H/AXEOAgIAAQtBACACIAlrIgEgASACSxsiBCANIAlrIgEgASAESxsiA0EAIAcgCUkbIAdqIQcgASAETQ0BIAAgASADayAIEHMMAQsgAEEIaiEEIAkgDWsiAyAJIAdBf3NqIgEgASADSxsiBQRAAkAgAiAFayIBIAQoAggiAksNACAEIAE2AgggASACRg0AIAIgAWshAiAEKAIEIAFBBHRqIQEDQCABKAIABEAgAUEEaigCABAVCyABQRBqIQEgAkEBayICDQALCyAAKAIQIgFFDQIgACgCDCABQQR0akEEa0EAOgAACyAHIANrIAVqIQcLIABBAToAHCAAIA02AhggACAINgIUIBEgBzYCBCARIAs2AgAgBkFAayQADAELQYybwABBK0GUnsAAEIsBAAsgACAQKQMINwJgIABB1ABqIQgCQCAAKAKYASIBIABB3ABqKAIAIgRNBEAgACABNgJcDAELIAggASAEa0EAEE8gACgCmAEhAQsgCEEAIAEQcCAAKAKUASIBIAAoAmxNBEAgACABQQFrNgJsCyAAKAKYASIBIABB8ABqKAIATQRAIAAgAUEBazYCcAsgEEEQaiQAC8QBAQJ/IwBBIGsiBCQAAkAgAiADaiIDIAJJDQAgASgCACICQQF0IgUgAyADIAVJGyIDQQggA0EISxsiA0F/c0EfdiEFAkAgAkUEQCAEQQA2AhgMAQsgBCACNgIcIARBATYCGCAEIAEoAgQ2AhQLIARBCGogBSADIARBFGoQPCAEKAIMIQUgBCgCCARAIARBEGooAgAhAwwBCyABIAM2AgAgASAFNgIEQYGAgIB4IQULIAAgAzYCBCAAIAU2AgAgBEEgaiQAC9oBAQJ/IwBBIGsiAyQAAkACQCABIAEgAmoiAUsNACAAKAIAIgJBAXQiBCABIAEgBEkbIgFBCCABQQhLGyIEQX9zQR92IQECQCACRQRAIANBADYCGAwBCyADIAI2AhwgA0EBNgIYIAMgACgCBDYCFAsgA0EIaiABIAQgA0EUahA9IAMoAgwhASADKAIIRQRAIAAgBDYCACAAIAE2AgQMAgsgAUGBgICAeEYNASABRQ0AIAEgA0EQaigCAEHo/cAAKAIAIgBB1gAgABsRAgAACxCSAQALIANBIGokAAvaAQECfyMAQSBrIgMkAAJAAkAgASABIAJqIgFLDQAgACgCACICQQF0IgQgASABIARJGyIBQQggAUEISxsiBEF/c0EfdiEBAkAgAkUEQCADQQA2AhgMAQsgAyACNgIcIANBATYCGCADIAAoAgQ2AhQLIANBCGogASAEIANBFGoQMiADKAIMIQEgAygCCEUEQCAAIAQ2AgAgACABNgIEDAILIAFBgYCAgHhGDQEgAUUNACABIANBEGooAgBB6P3AACgCACIAQdYAIAAbEQIAAAsQkgEACyADQSBqJAALxwEBAX8jAEEQayIPJAAgACgCFCABIAIgAEEYaigCACgCDBEBACEBIA9BADoADSAPIAE6AAwgDyAANgIIIA9BCGogAyAEIAUgBhAgIAcgCCAJIAoQICALIAwgDSAOECAhAiAPLQAMIQECfyABQQBHIA8tAA1FDQAaQQEgAQ0AGiACKAIAIgAtABxBBHFFBEAgACgCFEG/5sAAQQIgACgCGCgCDBEBAAwBCyAAKAIUQb7mwABBASAAKAIYKAIMEQEACyAPQRBqJAAL1gEBA38jAEHQAGsiACQAIABBMzYCDCAAQfCMwAA2AgggAEEANgIoIABCgICAgBA3AiAgAEHEAGpB1I3AADYCACAAQQM6AEwgAEEgNgI8IABBADYCSCAAQQA2AjQgAEEANgIsIAAgAEEgajYCQCAAQQhqIgEoAgAgASgCBCAAQSxqEOsBBEBB7I3AAEE3IABBEGpBpI7AAEGAj8AAEE4ACyAAQRBqIgFBCGogAEEoaigCACICNgIAIAAgACkCIDcDECAAKAIUIAIQASABELABIABB0ABqJAALrQEBAX8gACIEAn8CQAJ/AkACQCABBEAgAkEASA0BIAMoAgQEQCADQQhqKAIAIgAEQCADKAIAIAAgASACEL8BDAULCyACRQ0CQa39wAAtAAAaIAIgARDJAQwDCyAEQQA2AgQgBEEIaiACNgIADAMLIARBADYCBAwCCyABCyIABEAgBCAANgIEIARBCGogAjYCAEEADAILIAQgATYCBCAEQQhqIAI2AgALQQELNgIAC64BAQF/AkACQCABBEAgAkEASA0BAn8gAygCBARAAkAgA0EIaigCACIERQRADAELIAMoAgAgBCABIAIQvwEMAgsLIAEgAkUNABpBrf3AAC0AABogAiABEMkBCyIDBEAgACADNgIEIABBCGogAjYCACAAQQA2AgAPCyAAIAE2AgQgAEEIaiACNgIADAILIABBADYCBCAAQQhqIAI2AgAMAQsgAEEANgIECyAAQQE2AgALtAEBA38jAEEQayICJAAgAkKAgICAwAA3AgQgAkEANgIMQQAgAUEIayIEIAEgBEkbIgFBA3YgAUEHcUEAR2oiBARAQQghAQNAIAIoAgQgA0YEQCACQQRqIAMQeCACKAIMIQMLIAIoAgggA0ECdGogATYCACACIAIoAgxBAWoiAzYCDCABQQhqIQEgBEEBayIEDQALCyAAIAIpAgQ3AgAgAEEIaiACQQxqKAIANgIAIAJBEGokAAu9AQEBfyMAQRBrIgskACAAKAIUIAEgAiAAQRhqKAIAKAIMEQEAIQEgC0EAOgANIAsgAToADCALIAA2AgggC0EIaiADIAQgBSAGECAgByAI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BigCBCAEQQF0akEAOwEAIAYgBigCCEEBajYCCAwBCyAEQQFrIQUgBARAIAYoAgQgBUEBdGoiBCAELwEAQQpsIAJqQTBrOwEADAELIAVBAEGIpcAAEFkACwwJCyAGQQc6ABggBhBNDAgLIAZBAzoAGCAGEE0MBwsgAyACECYMBgsgBkEAOgAYAkACQAJAAkACQAJAAkACQAJAIAZBFGooAgBFBEAgAkHg//8AcUHAAEYNASACQTdrDgICAwQLIAZBEGooAgAhBCACQTBGDQQgAkE4Rg0FIAQoAgAhBAwHCyADIAJBQGtB/wFxECYMBwsgA0H0AGogAykBqgE3AQAgA0H+AGogAy8BtgE7AQAgA0HwAGogA0HkAGooAgA2AgAgA0H8AGogA0GyAWovAQA7AQAgAyADKAJgIgIgAygClAFBAWsiBCACIARJGzYCbAwGCyADQQA6ALkBIAMgAykCbDcCYCADIANB9ABqKQEANwGqASADQbIBaiADQfwAai8BADsBACADIANB/gBqLwEAOwG2AQwFCyACQeMARw0EIAZBADoAGCMAQeAAayICJAAgAkEIaiADKAKUASIEIAMoApgBIgUgAygCQCADQcQAaigCAEEAEC0gAkEoaiAEIAVBAUEAQQAQLSADQQhqIgUQgAEgAygCCARAIANBDGooAgAQFQsgAyACKQIINwIAIANBGGogAkEIaiIEQRhqKQIANwIAIANBEGogBEEQaikCADcCACAFIARBCGopAgA3AgAgA0EgaiEEIANBKGoiBRCAASAFKAIABEAgA0EsaigCABAVCyAEIAIpAig3AgAgA0EAOgC0ASAEQRhqIAJBKGoiBUEYaikCADcCACAEQRBqIAVBEGopAgA3AgAgBEEIaiAFQQhqKQIANwIAIAJB1ABqIAMoApQBED4gA0HIAGohBCADKAJIBEAgA0HMAGooAgAQFQsgBCACKQJUNwIAIARBCGogAkHUAGoiB0EIaiIEKAIANgIAIANBsgFqQQA7AQAgA0GuAWpBAjoAACADQQI6AKoBIANB6ABqQQE6AAAgA0IANwJgIANBADsBqAEgA0EAOgC5ASADQYCABDYAtQEgA0IANwKcASADQZABakGAgIAINgIAIANBjAFqQQI6AAAgA0GIAWpBAjoAACADQYQBakEANgIAIANB/ABqQoCAgAg3AgAgA0H4AGpBAjoAACADQfQAakECOgAAIANCADcCbCADIAMoApgBIgVBAWs2AqQBIAIgBRBmIARBADYCACACIAIpAwA3AlQgByAFQQEQTyACQdAAaiAEKAIANgIAIAIgAikCVDcDSCADQdQAaiEEIAMoAlQEQCADQdgAaigCABAVCyAEIAIpA0g3AgAgBEEIaiACQdAAaigCADYCACADQQA6ALsBIAJB4ABqJAAMBAsgBCgCACIEQShGDQEMAgsgBCgCACIEQSNHDQEjAEEQayICJAACQAJAIAMoApgBIggEQCADQdgAaigCACEKIANB3ABqKAIAIQQgAygClAEhBwNAIAcEQEEAIQUDQCACQQA7AQwgAkECOgAIIAJBAjoABCACQcUANgIAIAMgBSAJIAIQgQEgByAFQQFqIgVHDQALCyAEIAlGDQIgCSAKakEBOgAAIAggCUEBaiIJRw0ACwsgAkEQaiQADAELIAQgBEHQqcAAEFkACwwCCyADQQE6AKgBDAELAkACQCAEQShrDgIAAQILIANBADoAqAEMAQsgAkEwRgRAIANBAToAqQEMAQsgA0EAOgCpAQsMBQsgBkEGOgAYDAQLIAZBADoAGAwDCyAGQQA6ABgCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAZBFGooAgBFBEAgAkFAag42AQIDEgQFBiIWBwgJCgsjIwwjIw0OIyMPECMRIyMjIyMiEhMjFBUWFxgjIyMhICMjIyMfHh0cIwsgBkEQaigCACEEAkAgAkHsAGsOBRkjIyMbAAsgAkHoAEYNGQwiCyMAQRBrIgIkACAGKAIEQZilwAAgBigCCBsvAQAhBSADQeQAaigCACEEIAMoAmAhByACQQxqIANBsgFqLwEAOwEAIAJBIDYCACACIAMpAaoBNwIEIAMoAhQgB2shCCADIARBtJzAABB9IAcgBUEBIAVBAUsbIgUgCCAFIAhJGyACEEEgA0HcAGooAgAiBSAETQRAIAQgBUHQqcAAEFkACyADQdgAaigCACAEakEBOgAAIAJBEGokAAwhCyADQQA6ALkBIAMgAygCYCICIAMoApQBQQFrIgQgAiAESRs2AmBBACADKAKgASICIANB5ABqIgQoAgAiBSAC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7ABqIgooAgA2AgAgCiAMNgIAIAlBBGoiCUEURw0AC0EAIQkDQCADIAlqIgpBIGoiCygCACEMIAsgCigCADYCACAKIAw2AgAgCUEEaiIJQSBHDQALIAIgAygClAEgAygCmAEiCUEBQQAgA0GqAWoQLSADQQhqIgoQgAEgAygCCARAIANBDGooAgAQFQsgAyACKQIANwIAIANBGGogAkEYaikCADcCACADQRBqIAJBEGopAgA3AgAgCiACQQhqKQIANwIAIANB1ABqQQAgCRBwCyACQSBqJAAgAxA2DAELIAMgAygCZDYCcCAHIAgpAQA3AQAgAyADLwG2ATsBfiAHQQhqIAhBCGovAQA7AQAgAyADKAJgIgIgAygClAFBAWsiCSACIAlJGzYCbAsgBEECaiEEIAVBAmsiBQ0ACwsMCAsgBCgCAEEhRw0HIANBADsAtQEgA0ECOgCqASADQQA7AagBIANCADcCnAEgA0IANwJsIANB6ABqQQE6AAAgA0GyAWpBADsBACADQa4BakECOgAAIANB/ABqQYCAgAg2AgAgA0H4AGpBAjoAACADQfQAakECOgAAIAMgAygCmAFBAWs2AqQBDAcLIANBADoAuQEgAyADKQJsNwJgIAMgA0H0AGopAQA3AaoBIANBsgFqIANB/ABqLwEAOwEAIAMgA0H+AGovAQA7AbYBDAYLAkAgAy0AugFFDQAgBigCBCICQZilwAAgBigCCCIEGy8BAEEIRw0AIAJBAmpBmKXAACAEQQFLGy8BACIFIAMoApgBIgkgBRshCiACQQRqQZilwAAgBEECSxsvAQAiBCADKAKUASICIAQbIQgCQAJAAkACQEF/IAIgCEcgAiAISxtB/wFxDgIDAQALIANB0ABqKAIAIgIEQCADQcwAaigCACELIAIhBANAIAsgAkEBdiAHaiICQQJ0aigCACAISSEFIAQgAiAFGyIEIAJBAWogByAFGyIHayECIAQgB0sNAAsLIAMgBzYCUAwBCyADQcgAaiEFQQAgCCACQXhxQQhqIgRrIgIgAiAISxsiAkEDdiACQQdxQQBHaiICBEBBACACayEJIAUoAgghAgNAIAUoAgAgAkYEQCAFIAIQeCAFKAIIIQILIAUoAgQgAkECdGogBDYCACAFIAUoAghBAWoiAjYCCCAEQQhqIQQgCUEBaiIJDQALCyAD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IQggAygCBCEJA0AgBUEIaiACEFwgBSgCCCEKIAUoAgwgCSAHEO8BIQsgACgCAARAIABBBGooAgAQFQsgACAIOgAMIAAgAjYCCCAAIAs2AgQgACAKNgIAIAYgAEEQaiIARw0ACwsgASgCAARAIAEoAgQQFQsgASADKQIANwIAIAFBCGogA0EIaikCADcCAAwBCyADKAIARQ0AIAMoAgQQFQsgBUEQaiQAIARBIGokAA8LIAEgAkHknsAAEFsACyACIABB5J7AABBaAAt8AQJ/IABBADoAuQEgACAAKAJgIgIgACgClAFBAWsiAyACIANJGzYCYCAAKAKYAUEBayAAKAKkASICIAIgAEHkAGoiAigCACIDSRshACACIAAgAyABKAIEQZilwAAgASgCCBsvAQAiAUEBIAFBAUsbaiIBIAAgAUkbNgIAC2sBBX8CQCAAKAIIIgJFDQAgACgCBEEQayEEIAJBBHQhAyACQQFrQf////8AcUEBaiEFAkADQCADIARqEGtFDQEgAUEBaiEBIANBEGsiAw0ACyAFIQELIAFBAWsgAk8NACAAIAIgAWs2AggLC3UBAn8jAEEQayIEJAAgBEEIaiABKAIQIAIgAxDAASAEKAIMIQIgBCgCCCIDRQRAAkAgASgCCEUNACABQQxqKAIAIgVBhAFJDQAgBRAACyABQQE2AgggAUEMaiACNgIACyAAIAM2AgAgACACNgIEIARBEGokAAt2AQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEIaiIAQQxqQgI3AgAgAkEgaiIBQQxqQdUANgIAIAJBAzYCDCACQcjiwAA2AgggAkHVADYCJCACIAE2AhAgAiACQQRqNgIoIAIgAjYCICAAQfyawAAQkwEAC3MBAX8jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQhqIgBBDGpCAjcCACADQSBqIgFBDGpB1QA2AgAgA0ECNgIMIANBoOnAADYCCCADQdUANgIkIAMgATYCECADIANBBGo2AiggAyADNgIgIAAgAhCTAQALcwEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBCGoiAEEMakICNwIAIANBIGoiAUEMakHVADYCACADQQI2AgwgA0HU5MAANgIIIANB1QA2AiQgAyABNgIQIAMgAzYCKCADIANBBGo2AiAgACAC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CCEDIARBDGooAgAhAiAEKAIAIQcgBCgCBCEIIAQtABAhBCMAQSBrIgEkACAAIAMgAiAHIAhBABAtIABBIGogAyACQQFBAEEAEC0gASACEGYgAUEUaiIGQQhqIglBADYCACABIAEpAwA3AhQgBiACQQEQTyABQRBqIgYgCSgCADYCACABIAEpAhQ3AwggAEHIAGogAxA+IABBADoAtAEgACACNgKYASAAIAM2ApQBIABBkAFqQYCAgAg2AgAgAEGMAWpBAjoAACAAQYgBakECOgAAIABBhAFqQQA2AgAgAEH8AGpCgICACDcCACAAQfgAakECOgAAIABB9ABqQQI6AAAgAEIANwJsIAAgBzYCQCAAQcQAaiAINgIAIABB6ABqQQE6AAAgAEECOgCqASAAQa4BakECOgAAIABBsgFqQQA7AQAgAEIANwJgIABBADsBqAEgAEGAgAQ2ALUBIABBADoAuQEgAEIANwKcASAAIAJBAWs2AqQBIABBADoAuwEgACAEOgC6ASAAIAEpAwg3AlQgAEHcAGogBigCADYCACABQSBqJABBrf3AAC0AABpB3AFBBBDJASIBRQRAQQRB3AFB6P3AACgCACIAQdYAIAAbEQIAAAsgAUEANgIAIAFBBGogAEHYARDvARogBUHwAWokACABC2ABAX8CQAJAAkAgAUUEQEEBIQIMAQsgAUEASA0BQa39wAAtAAAaIAFBARDJASICRQ0CCyAAIAI2AgQgACABNgIADwsQkgEAC0EBIAFB6P3AACgCACIAQdYAIAAbEQIAAAvpBAEHfyMAQRBrIgYkACAGQQhqIAEgAkECEFYCfyAGKAIIBEBBASECIAYoAgwMAQsjAEEgayIFJAAgASICKAIIIQEgAkEANgIIAn8CQAJAIAEEQCAFIAJBDGooAgAiATYCFCAFQQhqIQkgAigCECEHIwBB0ABrIgQkAAJAIAMtAABFBEAgBCADLQABuBADNgIEIARBADYCACAEKAIEIQMgBCgCACEHDAELIARBIGoiCkEMakIDNwIAIARBzABqQSo2AgAgBEE4aiIIQQxqQSo2AgAgBEEENgIkIARBrJDAADYCICAEIANBA2o2AkggBCADQQJqNgJAIARBKjYCPCAEIANBAWo2AjggBCAINgIoIARBFGoiCCAKEB0gBEEIaiAHIAQoAhggBCgCHBDA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AgwMAQsgBEEQaiEGIAJBBGohAiMAQUBqIgEkACABQTBqIARBHGoQtgECfwJAAkACfwJAIAEoAjAEQCABQSBqIgVBCGogAUE4aigCADYCACABIAEpAjA3AyAgAUEYaiAFIAIQYyABKAIYRQ0BIAEoAhwMAgsgASgCNCECDAILIAFBEGogAUEgaiACQQRqEGMgASgCEEUNAiABKAIUCyECIAEoAiQiBUGEAUkNACAFEAALQQEMAQsgAUEwaiICQQhqIAFBKGooAgA2AgAgASABKQMgNwMwIAFBCGoiBSACKAIENgIEIAVBADYCACABKAIMIQIgASgCCAshBSAGIAI2AgQgBiAFNgIAIAFBQGskACAEKAIQIQEgBCgCFAs2AgQgAyABNgIAIARBIGokACADKAIEIQIgAygCAARAIAMgAjYCFEGwgMAAQSsgA0EUakHcgMAAQcCEwAAQTgALIANBIGokACAAIAAoAgBBAWs2AgAgAg8LEOMBAAsQ5AEAC0UBAX8gAiABayIDIAAoAgAgACgCCCICa0sEQCAAIAIgAxB7IAAoAgghAgsgACgCBCACaiABIAMQ7wEaIAAgAiADajYCCAtGAQN/IAFBEGooAgAiAiABKAIYIgNrIQQgAiADSQRAIAQgAkHEnsAAEFgACyAAIAM2AgQgACABQQxqKAIAIARBBHRqNgIAC0YBA38gAUEQaigCACICIAEoAhgiA2shBCACIANJBEAgBCACQdSewAAQWAALIAAgAzYCBCAAIAFBDGooAgAgBEEEdGo2AgALTwECfyAAKAIEIQIgACgCACEDAkAgACgCCCIALQAARQ0AIANBsObAAEEEIAIoAgwRAQBFDQBBAQ8LIAAgAUEKRjoAACADIAEgAigCEBEAAAtNAQF/IwBBEGsiAiQAIAIgACgCACIAQQxqNgIMIAFBtI/AAEEEQbiPwABBBSAAQcCPwABB0I/AAEEHIAJBDGpB2I/AABA/IAJBEGokAAtCAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEDggACgCCCEDCyAAKAIEIANqIAEgAhDvARogACACIANqNgIIQQALXwECf0Gt/cAALQAAGiABKAIEIQIgASgCACEDQQhBBBDJASIBRQRAQQRBCEHo/cAAKAIAIgBB1gAgABsRAgAACyABIAI2AgQgASADNgIAIABBiN/AADYCBCAAIAE2AgALQgEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhA5IAAoAgghAwsgACgCBCADaiABIAIQ7wEaIAAgAiADajYCCEEAC0gBAX8jAEEgayIDJAAgA0EMakIANwIAIANBATYCBCADQYzjwAA2AgggAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEJMBAAtJAQF/IwBBEGsiAiQAIAIgADYCDCABQYCAwABBAkGCgMAAQQYgAEG8AWpBiIDAAEGYgMAAQQggAkEMakGggMAAED8gAkEQaiQAC/4BAQJ/IwBBEGsiAyQAIAMgACgCACIAQQRqNgIMIwBBEGsiAiQAIAIgASgCFEGQj8AAQQQgAUEYaigCACgCDBEBADoADCACIAE2AgggAkEAOgANIAJBADYCBCACQQRqIABBlI/AABAqIANBDGpBpI/AABAqIQACfyACLQAMIgFBAEcgACgCACIARQ0AGkEBIAENABogAigCCCEBAkAgAEEBRw0AIAItAA1FDQAgAS0AHEEEcQ0AQQEgASgCFEHE5sAAQQEgAUEYaigCACgCDBEBAA0BGgsgASgCFEHS48AAQQEgAUEYaigCACgCDBEBAAsgAkEQaiQAIANBEGokAAs5AAJAAn8gAkGAgMQARwRAQQEgACACIAEoAhARAAANARoLIAMNAUEACw8LIAAgAyAEIAEoAgwRAQALzAIBA38gACgCACEAIAEoAhwiA0EQcUUEQCADQSBxRQRAIAAzAQAgARAjDwsjAEGAAWsiAyQAIAAvAQAhAkEAIQADQCAAIANqQf8AakEwQTcgAkEPcSIEQQpJGyAEajoAACAAQQFrIQAgAkH//wNxIgRBBHYhAiAEQRBPDQALIABBgAFqIgJBgAFLBEAgAkGAAUHk5sAAEFgACyABQfTmwABBAiAAIANqQYABakEAIABrEBQgA0GAAWokAA8LIwBBgAFrIgMkACAALwEAIQJBACEAA0AgACADakH/AGpBMEHXACACQQ9xIgRBCkkbIARqOgAAIABBAWshACACQf//A3EiBEEEdiECIARBEE8NAAsgAEGAAWoiAkGAAUsEQCACQYABQeTmwAAQWAALIAFB9ObAAEECIAAgA2pBgAFqQQAgAGsQFCADQYABaiQACzcBAX8gACgCACEAIAEoAhwiAkEQcUUEQCACQSBxRQRAIAAgARDXAQ8LIAAgARBFDwsgACABEEILNwEBfyAAKAIAIQAgASgCHCICQRBxRQRAIAJBIHFFBEAgACABENgBDwsgACABEEMPCyAAIAEQRAtAAQF/IwBBIGsiACQAIABBFGpCADcCACAAQQE2AgwgAEGA4cAANgIIIABBsODAADYCECAAQQhqQYjhwAAQkwEAC7YCAQJ/IwBBIGsiAiQAIAJBATsBHCACIAE2AhggAiAANgIUIAJBkOTAADYCECACQYzjwAA2AgwjAEEQayIBJAAgAkEMaiIAKAIIIgJFBEBBoN3AAEErQejewAAQiwEACyABIAAoAgw2AgwgASAANgIIIAEgAjYCBCMAQRBrIgAkACABQQRqIgEoAgAiAkEMaigCACEDAkACfwJAAkAgAigCBA4CAAEDCyADDQJBACECQaDdwAAMAQsgAw0BIAIoAgAiAygCBCECIAMoAgALIQMgACACNgIEIAAgAzYCACAAQZjfwAAgASgCBCIAKAIIIAEoAgggAC0AECAALQAREDQACyAAIAI2AgwgAEGAgICAeDYCACAAQazfwAAgASgCBCIAKAIIIAEoAgggAC0AECAALQAREDQACzABAX8gASgCHCICQRBxRQRAIAJBIHFFBEAgACABENgBDwsgACABEEMPCyAAIAEQRAswAQF/IAEoAhwiAkEQcUUEQCACQSBxRQRAIAAgARDXAQ8LIAAgARBFDwsgACABEEILMwEBfyMAQRBrIgIkACACIAAoAgA2AgwgAUHMkMAAQQ0gAkEMakHckMAAEDMgAkEQaiQACzIAAkAgAEH8////B0sNACAARQRAQQQPC0Gt/cAALQAAGiAAQQQQyQEiAEUNACAADwsACzABAX8jAEEQayICJAAgAiAANgIMIAFB/4HAAEEGIAJBDGpBiILAABAzIAJBEGokAAswAQF/IwBBEGsiAiQAIAIgADYCDCABQfSDwABBBSACQQxqQfyDwAAQMyACQRBqJAALMAEBfyMAQRBrIgIkACACIAA2AgwgAUGchsAAQQQgAkEMakGghsAAEDMgAkEQaiQACzABAX8jAEEQayICJAAgAiAANgIMIAFB1ozAAEEKIAJBDGpB4IzAABAzIAJBEGokAAu/EwIYfwV+IwBBEGsiFCQAIBQgATYCDCAUIAA2AgggFEEIaiEA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AgQQFQsLLwECfyAAIAAoAqABIgIgACgCpAFBAWoiAyABIABBqgFqECEgAEHUAGogAiADEHALLwECfyAAIAAoAqABIgIgACgCpAFBAWoiAyABIABBqgFqEFAgAEHUAGogAiADEHALKwAgASACSQRAQbSnwABBI0GkqMAAEIsBAAsgAiAAIAJBBHRqIAEgAmsQEws1AQF/IAEoAhRBjOTAAEEBIAFBGGooAgAoAgwRAQAhAiAAQQA6AAUgACACOgAEIAAgATYCAAsjAAJAIAFB/P///wdNBEAgACABQQQgAhC/ASIADQELAAsgAAslACAARQRAQeCXwABBMhDiAQALIAAgAiADIAQgBSABKAIQEQgACzMAIAEoAhQgAC0AAEECdCIAQYiFwABqKAIAIABB0ITAAGooAgAgAUEYaigCACgCDBEBAAszACABKAIUIAAtAABBAnQiAEGwjcAAaigCACAAQaSNwABqKAIAIAFBGGooAgAoAgwRAQALMwAgASgCFCAALQAAQQJ0IgBBxJPAAGooAgAgAEG4k8AAaigCACABQRhqKAIAKAIMEQEACyMAIABFBEBB4JfAAEEyEOIBAAsgACACIAMgBCABKAIQEQUACyMAIABFBEBB4JfAAEEyEOIBAAsgACACIAMgBCABKAIQERgACyMAIABFBEBB4JfAAEEyEOIBAAsgACACIAMgBCABKAIQERoACyMAIABFBEBB4JfAAEEyEOIBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBB4JfAAEEyEOIBAAsgACACIAMgBCABKAIQEQwACx8AIAAoAgBBgICAgHhyQYCAgIB4RwRAIAAoAgQQFQsLMQAgASgCFEGdkMAAQZiQwAAgACgCAC0AACIAG0EHQQUgABsgAUEYaigCACgCDBEBAAshACAARQRAQeCXwABBMhDiAQALIAAgAiADIAEoAhARAwALEQAgACgCAARAIAAoAgQQFQsLIgAgAC0AAEUEQCABQeDowABBBRARDwsgAUHl6MAAQQQQEQsuACABKAIUQfuLwABB9IvAACAALQAAIgAbQQlBByAAGyABQRhqKAIAKAIMEQEACx8AIABFBEBB4JfAAEEyEOIBAAsgACACIAEoAhARAAALDwAgABCwASAAQQxqELABCxsAEAchAiAAQQA2AgggACACNgIEIAAgATYC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CyACIQAMAQsgBiAEIAVBAXFyQQJyNgIAIAQgCGoiAiABIARrIgFBAXI2AgRBpIHBACABNgIAQayBwQAgAjYCAAsgAAsUACAAIAIgAxAFNgIEIABBADYCAAsLACABBEAgABAVCwsTACABKAIUIAFBGGooAgAgABAWCxEAIABBCGoiABCAASAAELABCxMAIAAoAgAgASgCACACKAIAEAwLEAAgACABIAEgAmoQgwFBAAsUACAAKAIAIAEgACgCBCgCDBEAAAuSAQECfyAAKAIEIQIgACgCCCEDIwBBEGsiACQAIABBBGogARCiASADBEAgA0EEdCEBA0AgACACNgIMIABBBGogAEEMakGMkcAAECkgAkEQaiECIAFBEGsiAQ0ACwsgAEEEaiIBLQAEBH9BAQUgASgCACIBKAIUQcbmwABBASABQRhqKAIAKAIMEQEACyAAQRBqJAALkgEBAn8gACgCBCECIAAoAgghAyMAQRBrIgAkACAAQQRqIAEQogEgAwRAIANBBHQhAQNAIAAgAjYCDCAAQQRqIABBDGpB7JHAABApIAJBEGohAiABQRBrIgENAAsLIABBBGoiAS0ABAR/QQEFIAEoAgAiASgCFEHG5sAAQQEgAUEYaigCACgCDBEBAAsgAEEQaiQACxkAAn8gAUEJTwRAIAEgABAcDAELIAAQDwsLEQAgACgCBCAAKAIIIAEQ6wELqAIBBn8jAEEQayIFJAACQAJAAkAgASgCCCICIAEoAgBPDQAgBUEIaiEGIwBBIGsiBCQAAkAgASgCACIDIAJPBEACf0GBgICAeCADRQ0AGiABKAIEIQcCQCACRQRAQQEhAyAHEBUMAQtBASAHIANBASACEL8BIgNFDQEaCyABIAI2AgAgASADNgIEQYGAgIB4CyEDIAYgAjYCBCAGIAM2AgAgBEEgaiQADAELIARBFGpCADcCACAEQQE2AgwgBEG8mcAANgIIIARBmJnAADYCECAEQQhqQZCawAAQkwEACyAFKAIIIgJBgYCAgHhGDQAgAkUNASACIAUoAgxB6P3AACgCACIAQdYAIAAbEQIAAAsgBUEQaiQADAELEJIBAAsgACABKQIENwMACw4AIAAgASABIAJqEIMBCyAAIABC5N7HhZDQhd59NwMIIABCwff56MyTstFBNwMACyIAIABCjYSZ6OiU74GjfzcD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c3RkL3NyYy90aHJlYWQvbG9jYWwucnMAKAoQAE8AAAD2AAAAGgAAAP//////////iAoQAEGglcAAC9gVIGNhbid0IGJlIHJlcHJlc2VudGVkIGFzIGEgSmF2YVNjcmlwdCBudW1iZXKIChAAAAAAAKAKEAAsAAAARAAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3NlcmRlLXdhc20tYmluZGdlbi0wLjQuNS9zcmMvbGliLnJzAAAA4AoQAGUAAAA1AAAADgAAAFRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0eVgLEAAkAAAAL3J1c3RjLzA3ZGNhNDg5YWMyZDkzM2M3OGQzYzUxNThlM2Y0M2JlZWZlYjAyY2UvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc4QLEABMAAAAzwEAAAkAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZEpzVmFsdWUoKQASDBAACAAAABoMEAABAAAAbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAAAVHJpZWQgdG8gc2hyaW5rIHRvIGEgbGFyZ2VyIGNhcGFjaXR5mAwQACQAAAAvcnVzdGMvMDdkY2E0ODlhYzJkOTMzYzc4ZDNjNTE1OGUzZjQzYmVlZmViMDJjZS9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzxAwQAEwAAADPAQAACQAAAC9ydXN0Yy8wN2RjYTQ4OWFjMmQ5MzNjNzhkM2M1MTU4ZTNmNDNiZWVmZWIwMmNlL2xpYnJhcnkvYWxsb2Mvc3JjL3ZlYy9tb2QucnMgDRAATAAAACQIAAAkAAAAIA0QAEwAAADvBQAAFQAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hdnQtMC4xMC4yL3NyYy9idWZmZXIucnMAAAC3DRAAWgAAAGEAAAANAAAAtw0QAFoAAABlAAAADQAAALcNEABaAAAAagAAAA0AAAC3DRAAWgAAAG8AAAAdAAAAtw0QAFoAAAB8AAAAJQAAALcNEABaAAAAhgAAACUAAAC3DRAAWgAAAI4AAAAVAAAAtw0QAFoAAACYAAAAJQAAALcNEABaAAAAnwAAABUAAAC3DRAAWgAAAKQAAAAlAAAAtw0QAFoAAACvAAAAEQAAALcNEABaAAAAvgAAABEAAAC3DRAAWgAAAMAAAAARAAAAtw0QAFoAAADKAAAADQAAALcNEABaAAAAzgAAABEAAAC3DRAAWgAAANEAAAANAAAAtw0QAFoAAAD7AAAAKwAAALcNEABaAAAAQAEAACwAAAC3DRAAWgAAADkBAAAbAAAAtw0QAFoAAABMAQAAFAAAALcNEABaAAAAXgEAABgAAAC3DRAAWgAAAGMBAAAYAAAAYXNzZXJ0aW9uIGZhaWxlZDogbGluZXMuaXRlcigpLmFsbCh8bHwgbC5sZW4oKSA9PSBjb2xzKQC3DRAAWgAAANIBAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKCkvcnVzdGMvMDdkY2E0ODlhYzJkOTMzYzc4ZDNjNTE1OGUzZjQzYmVlZmViMDJjZS9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21vZC5yc98PEABNAAAAaA0AAAkAAABhc3NlcnRpb24gZmFpbGVkOiBrIDw9IHNlbGYubGVuKCkAAADfDxAATQAAAJMNAAAJAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvYXZ0LTAuMTAuMi9zcmMvbGluZS5yc3AQEABYAAAAFgAAABMAAABwEBAAWAAAABoAAAATAAAAcBAQAFgAAAAeAAAAEwAAAHAQEABYAAAAHwAAABMAAABwEBAAWAAAACMAAAATAAAAcBAQAFgAAAAlAAAAEwAAAHAQEABYAAAAOgAAACUAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hdnQtMC4xMC4yL3NyYy90YWJzLnJzOBEQAFgAAAAXAAAAFAAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2F2dC0wLjEwLjIvc3JjL3Rlcm1pbmFsLnJzoBEQAFwAAABwAQAAFQAAAKAREABcAAAApwEAABEAAACgERAAXAAAAOYCAAAjAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvYXZ0LTAuMTAuMi9zcmMvcGFyc2VyLnJzAAAsEhAAWgAAAIwBAAAnAAAAAAAAAFIAAAAMAAAABAAAAFMAAABUAAAALgAAAGYmAACSJQAACSQAAAwkAAANJAAACiQAALAAAACxAAAAJCQAAAskAAAYJQAAECUAAAwlAAAUJQAAPCUAALojAAC7IwAAACUAALwjAAC9IwAAHCUAACQlAAA0JQAALCUAAAIlAABkIgAAZSIAAMADAABgIgAAowAAAMUiAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi91bmljb2RlLXdpZHRoLTAuMS4xMS9zcmMvdGFibGVzLnJzMBMQAGQAAAAnAAAAGQAAADATEABkAAAALQAAAB0AAABhc3NlcnRpb24gZmFpbGVkOiBtaWQgPD0gc2VsZi5sZW4oKS9ydXN0Yy8wN2RjYTQ4OWFjMmQ5MzNjNzhkM2M1MTU4ZTNmNDNiZWVmZWIwMmNlL2xpYnJhcnkvY29yZS9zcmMvc2xpY2UvbW9kLnJz1xMQAE0AAABoDQAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IGsgPD0gc2VsZi5sZW4oKQAAANcTEABNAAAAkw0AAAkAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hdnQtMC4xMC4yL3NyYy90ZXJtaW5hbC9kaXJ0eV9saW5lcy5yc2gUEABoAAAADAAAAA8AAABoFBAAaAAAABAAAAAPAAAAAAECAwMEBQYHCAkKCwwNDgMDAwMDAwMPAwMDAwMDAw8JCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCRAJCQkJCQkJERERERERERIREREREREREgBB8avAAAufFAECAwQFBgcGCAYJCgsMDQ4PEAYGBhESExQGFRYXGBkaGxwdHh8gISIjIiQlJicoKSolKywtLi8wMTIzNDU2Nzg5OgY7PAoKBgYGBgY9BgYGBgYGBgYGBgYGBgY+P0BBQgZDBkQGBgZFRkdISUpLTE0GBk4GBgYKBgYGBgYGBgZPUFFSU1RVVldYWQZaBgZbBlxdXl1fYGFiY2RlZmdoBgYGBgYGBgYGBgYGBmlqBgYGBgZrBgEGbAYGbW47OztvcHFyO3M7dHV2dzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt4eQYGBgYGent8BgYGBn0GBn5/gIGCg4SFhgYGBoc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzuIBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXTs7Ozs7Ozs7iQYGBgYGBgYGBgYGiosGAXGMBo0GBgYGBgYGjgYGBo8GkAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGkQYGkgYGBgYGBgYGkwYGBgYGlJUGlpcGmJmam5ydnp+gLgahLKIGBqOkpaYGBqeoqaqrBqwGBgatBgYGrq8GsLGyswYGBgYGtAa1Bra3uAYGBga5ursGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGR7wGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGvb4GBgYGBgYGBgYGBgYGBgYGv8DBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzvCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O8PEBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGxTs7OzvGxzs7Ozs7yAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGyQYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgbKywYGBgYGBgbMzQYGzgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBs/Q0QYGBgYGBgYGBgYGBgYGBgYGBgYGBtIGvwa+BgYGBgbT1AYGBgYGBgbUBgYGBgYGBgYGBgYGBgYG1QbWBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgbXBgbY2drbBtzdBgbe3+Dh4uM75OXm5+g76TvqBgYG6wYGBgbs7Ts7Bu7v8AYGBgYGBgYGBgYGBgYGBgYGBgYGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O+XxCgYGCgoKCwYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBl1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXfIAAAAAAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFQAAAAAAAAAAXdd3df/3f/9VdVVVV9VX9V91f1/31X93XVVVVd1V1VVV9dVV/VVX1X9X/131VVVVVfXVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVdXd3d1dVVVVVVVVVVVVVVVVdVVVVXVVVVVVVVVVV1/1dV1X/3VVVVVVVVVVVAEGswMAAC1lVVVVVVVVVVf3////f/19V/f///9//X1VVVVVVVVVVVVVVVVVdVVVV/////////////////////11VVVVVVVVVVVVVVRUAUFVVVVVVVVVVVVVVVVVVVVVVAQBBj8HAAAu0ARBBEFVVVVVVVVVVVVVVVVVVAFBVVQAAQFRVVVVVVVVVVVVVFQAAAAAAVVVVVVRVVVVVVVVVVQUAEAAUBFBVVVVVVVVVFVFVVVVVVVVVAAAAAAAAQFVVVVVVVVVVVVVVVVVVVVVVVVVVVVUFAABUVVVVVVVVVVVVVVVVVRUAAFVVUVVVVVVVBRAAAAEBUFVVVVVVVVVVVVUBVVVVVVVVVVVVVVVVVVBVAABVVVVVVVVVVVVVBQBB0MLAAAvAFUBVVVVVVVVVVVVVVVVVRVQBAFRRAQBVVQVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVAFUVVFVVVVVBVVVVVVVVUVBVVVVVVVVVVVVVVVVVVVUQRUUUFFVVVVVVVVVUFFVVQEQVFFVVVVVBVVVVVVVBQBRVVVVVVVVVVVVVVVVVVUUAVRVUVVBVVUFVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVVUVVVRVVVVVVVVVVVVVVVVVFRVVVVVVVVVVVVVVVVVBFQFBFBVQVVVBVVVVVVVVVVVRVVQVVVVVQVVVVVVVVVVUFVVVVVVVVVVVVVVVVUVVAFUVVFVVVVVBVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVVVFVQVEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVEAQFVVFQBAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUQAAVFVVAEBVVVVVVVVVVVVVVVVVVVVVVVVQVVVVVVVVEVFVVVVVVVVVVVVVVVVVAQAAQAAEVQEAAAEAAAAAAAAAAFRVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUBBABBQVVVVVVVVVAFVFVVVQFUVVVFQVVRVVVVUVVVVVVVVVVVqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqAAAAAAAAAABVVVVVVVVVAVVVVVVVVVVVVVVVVQVUVVVVVVVVBVVVVVVVVVUFVVVVVVVVVQVVVVVVVVVVVVVVVVVVVVVVEABQVUUBAABVVVFVVVVVVVVVVVVVFQBVVVVVVVVVVVVVVVVVQVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVAFVRVRVUBVVVVVVVVFRRVVVVVVVVVVVVVVVVVVUUAQEQBAFQVAAAUVVVVVVVVVVVVVVVVAAAAAAAAAEBVVVVVVVVVVVVVVVUAVVVVVVVVVVVVVVVVBEBURVVVVVVVVVVVVRUAAFVVVVBVVVVVVVVVBVAQUFVVVVVVVVVVVVVVVVVFUBFQVVVVVVVVVVVVVVVVVVUAAAVVVVVVVVVAAAAABABUUVVUUFVVVRUA139fX3//BUD3XdV1VVVVVVVVVVUABAAAVVdV1f1XVVVVVVVVVVVVV1VVVVVVVVVVAAAAAAAAAABUVVVV1V1dVdV1VVV9ddVVVVVVVVVVVVXVV9V/////Vf//X1VVVV1V//9fVVVVVVVVVV9VVVVVVXVXVVVV1VVVVVVVVffV19VdXXX9193/d1X/VV9VVVdXdVVVVV//9fVVVVVV9fVVVVVdXVVVXVVVVVVV1VVVVVV1VaVVVVVpVVVVVVVVVVVVVVVVVVVVqVaWVVVVVVVVVVVVVVX/////////////////////////////////////////////3///////////Vf///////////1VVVf/////1X1VV3/9fVfX1VV9f9df1X1VVVfVfVdVVVVVpVX1d9VVaVXdVVVVVVVVVVXdVqqqqVVVV399/31VVVZVVVVVVlVVV9VlVpVVVVVXpVfr/7//+///fVe//r/vv+1VZpVVVVVVVVVVWVVVVVV1VVVVmlZpVVVVVVVVV9f//VVVVVVWpVVVVVVVVVlVVlVVVVVVVVZVWVVVVVVVVVVVVVVVVVvlfVVVVVVVVVVVVVVVVVVVVVVVVVVUVUFVVVVVVVVVVVVVVAAAAAAAAAACqqqqqqqqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqlVVVaqqqqqqWlVVVVVVVaqqqqqqqqqqqqqqqqqqCqCqqqpqqaqqqqqqqqqqqqqqqqqqqqqqqqqqaoGqqqqqqqqqqqpVqaqqqqqqqqqqqqqpqqqqqqqqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqlVVlaqqqqqqqqqqqqqqaqqqqqqqqqqqqqr//6qqqqqqqqqqqqqqqqqqqlaqqqqqqqqqqqqqqqqqalVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVQAAAUFVVVVVVVVUFVVVVVVVVVVVVVVVVVVVVVVVVVVVQVVVVRUUVVVVVVVVVQVVUVVVVVVVQVVVVVVVVAAAAAFBVVRVVVVVVVVVVVVUFAFBVVVVVVRUAAFBVVVWqqqqqqqqqVkBVVVVVVVVVVVVVVRUFUFBVVVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVQFAQUFVVRVVVVRVVVVVVVVVVVVVVVRVVVVVVVVVVVVVVVUEFFQFUVVVVVVVVVVVVVVQVUVVVVVVVVVVVVVVVVFUUVVVVVWqqqqqqqqqqqpVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVQAAAACqqlpVAAAAAKqqqqqqqqqqaqqqqqpqqlVVVVVVqqqqqqqqqqpWVVVVVVVVVVVVVVVVVVVVqmpVVVVVAV1VVVVVVVVVVVVVVVVVVVVRVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVUFQFUBQVUAVVVVVVVVVVVVVUAVVVVVVVVVVVVVQVVVVVVVVVVVVVVVVVVVVQBVVVVVVVVVVVVVVVVVVVVVFVRVVVVVVVVVVVVVVVVVVVVVVVVVAVUFAABUVVVVVVVVVVVVVVUFUFVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVVVVVVVUAAABAVVVVVVVVVVVVVRRUVRVQVVVVVVVVVVVVVVUVQEFRRVVVUVVVVVVVVVVVVVVVVUBVVVVVVVVVVRUAAQBUVVVVVVVVVVVVVVVVVVUVVVVVUFVVVVVVVVVVVVVVVQUAQFVVARRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVQBFVFVVVVVVVVVRUVAEBVVVVVVVRVVVVVVVVVVQUAVABUVVVVVVVVVVVVVVVVVVVVVQAABURVVVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVVRUARBUEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVBVBVEFRVVVVVVVVQVVVVVVVVVVVVVVVVVVVVVVVVVVUVAEARVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVUQAQVVVVVVVVVVVVAQUQAFVVVVVVVVVVVVVVVVVVVVUVAABBVVVVVVVVVVVVVVVVVVVVFUQVVVVVVVVVVVVVVVVVVVVVVVVVVVUABVVUVVVVVVVVVQEAQFVVVVVVVVVVVRUAFEBVFVVVAUABVVVVVVVVVVVVVVUFAABAUFVVVVVVVVVVVVVVVVVVVVVVVVVVVQBAABBVVVVVBQAAAAAABQAEQVVVVVVVVVVVVVVVVVVVAUBFEAAQVVVVVVVVVVVVVVVVVVVVVVVVUBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFVRVVVBVVVVVVVVVVVVVVVUFQFVEVVVVVVVVVVVVVVVVVVVVVBUAAABQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQBUVVVVVVVVVVVVVVVVVVUAQFVVVVVVFVVVVVVVVVVVVVVVVVVVVRVAVVVVVVVVVVVVVVVVVVVVVVVVVapUVVVaVVVVqqqqqqqqqqqqqqqqqqpVVaqqqqqqWlVVVVVVVVVVVVWqqlZVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVqqmqaaqqqqqqqqqqalVVVWVVVVVVVVVVallVVVWqVVWqqqqqqqqqqqqqqqqqqqqqqqqqVVVVVVVVVVVBAFVVVVVVVVUAQZvYwAALRVAAAAAAAEBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVQVRUAAABAAQBVVVVVVVVVBVBVVVVVBVRVVVVVVVVVVVVVVVVVVQBB7djAAAsCQBUAQfvYwAALryRUVVFVVVVUVVVVVRUAAQAAAFVVVVUAQAAAAAAUABAEQFVVVVVVVVVVVVVVVVVVVVVFVVVVVVVVVVVVVVVVVVVVAFVVVVVVVVVVAEBVVVVVVVVVVVVVVQBAVVVVVVVVVVVVVVVVVVVWVVVVVVVVVVVVVVVVVVVVVVWVVVVVVVVVVVVVVVVV//9/Vf////////9f//////////////////9fVf/////////vq6rq/////1dVVVVValVVVaqqqqqqqqqqqqqqVaqqVlVaVVVVqlpVVVVVVVWqqqqqqqqqqlZVVamqmqqqqqqqqqqqqqqqqqqqqqqqpqqqqqqqVVVVqqqqqqqqqqqqqmqVqlVVVaqqqqpWVqqqqqqqqqqqqqqqqqqqqqqqaqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqWqqqqqqqqqqqqqqqqqqqqWlVVlWqqqqqqqqpVVVVVZVVVVVVVVWlVVVVWVVVVVVVVVVVVVVVVVVVVVVVVVVWVqqqqqqpVVVVVVVVVVVVVVVWqWlVWaqlVqlVVlVZVqqpWVVVVVVVVVVWqqqpVVlVVVVVVVaqqqqqqqqqqqqqqaqqqmqqqqqqqqqqqqqqqqqqqVVVVVVVVVVVVVVVVqqqqVqqqVlWqqqqqqqqqqqqqqpqqWlWlqqqqVaqqVlWqqlZVUVVVVVVVVVUAAAAAAAAAAP///////////////////19jYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAFcAAAAMAAAABAAAAFgAAABZAAAAWgAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAO8uEAAVAAAABC8QAA0AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMkLxAAGAAAAGIBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0wvEAAcAAAAhAIAAB4AAABXAAAADAAAAAQAAABbAAAAXAAAAAgAAAAEAAAAXQAAAFwAAAAIAAAABAAAAF4AAABfAAAAYAAAABAAAAAEAAAAYQAAAGIAAABjAAAAAAAAAAEAAABkAAAASGFzaCB0YWJsZSBjYXBhY2l0eSBvdmVyZmxvd9AvEAAcAAAAL3J1c3QvZGVwcy9oYXNoYnJvd24tMC4xNC4zL3NyYy9yYXcvbW9kLnJzAAD0LxAAKgAAAFYAAAAoAAAARXJyb3IAAABlAAAADAAAAAQAAABmAAAAZwAAAGgAAABsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzY2FwYWNpdHkgb3ZlcmZsb3cAAABsMBAAEQAAAFAwEAAcAAAAOwIAAAUAAABhIGZvcm1hdHRpbmcgdHJhaXQgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IAaQAAAAAAAAABAAAAagAAAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5yc9wwEAAYAAAAZAIAACAAAAApIHNob3VsZCBiZSA8IGxlbiAoaXMgKWluc2VydGlvbiBpbmRleCAoaXMgKSBzaG91bGQgYmUgPD0gbGVuIChpcyAAABsxEAAUAAAALzEQABcAAAAaMRAAAQAAAHJlbW92YWwgaW5kZXggKGlzIAAAYDEQABIAAAAEMRAAFgAAABoxEAABAAAAbGlicmFyeS9jb3JlL3NyYy9mbXQvbW9kLnJzY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZSkwMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAA8TEQABIAAABbAAAAcAAAAAAAAAABAAAAcQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAgMhAAIAAAAEAyEAASAAAAcgAAAAQAAAAEAAAAcwAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogAH8yEAAQAAAAjzIQABcAAACmMhAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAB/MhAAEAAAAMgyEAAQAAAA2DIQAAkAAACmMhAACQAAADogAACMMRAAAAAAAAQzEAACAAAAcgAAAAwAAAAEAAAAdAAAAHUAAAB2AAAAICAgICB7ICwgIHsKLAp9IH0oKAosCl1saWJyYXJ5L2NvcmUvc3JjL2ZtdC9udW0ucnMAAEczEAAbAAAAaQAAABcAAAAweDAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5AACMMRAAGwAAAOAHAAAJAAAAcgAAAAgAAAAEAAAAbQAAAGZhbHNldHJ1ZXJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCAAAABpNBAAEgAAAHs0EAAiAAAAcmFuZ2UgZW5kIGluZGV4ILA0EAAQAAAAezQQACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IADQNBAAFgAAAOY0EAANAAAAbGlicmFyeS9jb3JlL3NyYy91bmljb2RlL3ByaW50YWJsZS5y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AwEeAgMBCwI5AQQFAQIEARQCFgYBAToBAQIBBAgBBwMKAh4BOwEBAQwBCQEoAQMBNwEBAwUDAQQHAgsCHQE6AQIBAgEDAQUCBwILAhwCOQIBAQIECAEJAQoCHQFIAQQBAgMBAQgBUQECBwwIYgECCQsHSQIbAQEBAQE3DgEFAQIFCwEkCQFmBAEGAQICAhkCBAMQBA0BAgIGAQ8BAAMAAx0CHgIeAkACAQcIAQILCQEtAwEBdQIiAXYDBAIJAQYD2wICAToBAQcBAQEBAggGCgIBMB8xBDAHAQEFASgJDAIgBAICAQM4AQECAwEBAzoIAgKYAwENAQcEAQYBAwLGQAABwyEAA40BYCAABmkCAAQBCiACUAIAAQMBBAEZAgUBlwIaEg0BJggZCy4DMAECBAICJwFDBgICAgIMAQgBLwEzAQEDAgIFAgEBKgIIAe4BAgEEAQABABAQEAACAAHiAZUFAAMBAgUEKAMEAaUCAAQAAlADRgsxBHsBNg8pAQICCgMxBAICBwE9AyQFAQg+AQwCNAkKBAIBXwMCAQECBgECAZ0BAwgVAjkCAQEBARYBDgcDBcMIAgMBARcBUQECBgEBAgEBAgEC6wECBAYCAQIbAlUIAgEBAmoBAQECBgEBZQMCBAEFAAkBAvUBCgIBAQQBkAQCAgQBIAooBgIECAEJBgIDLg0BAgAHAQYBAVIWAgcBAgECegYDAQECAQcBAUgCAwEBAQACCwI0BQUBAQEAAQYPAAU7BwABPwRRAQACAC4CFwABAQMEBQgIAgceBJQDADcEMggBDgEWBQEPAAcBEQIHAQIBBWQBoAcAAT0EAAQAB20HAGCA8AB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS43Ni4wICgwN2RjYTQ4OWEgMjAyNC0wMi0wNCkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjg0IChjZWE4Y2MzZDIpACwPdGFyZ2V0X2ZlYXR1cmVzAisPbXV0YWJsZS1nbG9iYWxzKwhzaWduLWV4dA==\");\n\n        var loadVt = async () => {\n                await init(wasm_code);\n                return exports;\n            };\n\nfunction parseNpt(time) {\n  if (typeof time === \"number\") {\n    return time;\n  } else if (typeof time === \"string\") {\n    return time.split(\":\").reverse().map(parseFloat).reduce((sum, n, i) => sum + n * Math.pow(60, i));\n  } else {\n    return undefined;\n  }\n}\nfunction debounce(f, delay) {\n  let timeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    clearTimeout(timeout);\n    timeout = setTimeout(() => f.apply(this, args), delay);\n  };\n}\nfunction throttle(f, interval) {\n  let enableCall = true;\n  return function () {\n    if (!enableCall) return;\n    enableCall = false;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    f.apply(this, args);\n    setTimeout(() => enableCall = true, interval);\n  };\n}\n\nclass Clock {\n  constructor() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n    this.speed = speed;\n    this.startTime = performance.now();\n  }\n  getTime() {\n    return this.speed * (performance.now() - this.startTime) / 1000.0;\n  }\n  setTime(time) {\n    this.startTime = performance.now() - time / this.speed * 1000.0;\n  }\n}\nclass NullClock {\n  constructor() {}\n  getTime(_speed) {}\n  setTime(_time) {}\n}\n\nconst vt = loadVt(); // trigger async loading of wasm\n\nclass State {\n  constructor(core) {\n    this.core = core;\n    this.driver = core.driver;\n  }\n  onEnter(data) {}\n  init() {}\n  play() {}\n  pause() {}\n  togglePlay() {}\n  seek(where) {\n    return false;\n  }\n  step() {}\n  stop() {\n    this.driver.stop();\n  }\n}\nclass UninitializedState extends State {\n  async init() {\n    try {\n      await this.core.initializeDriver();\n      return this.core.setState(\"stopped\");\n    } catch (e) {\n      this.core.setState(\"errored\");\n      throw e;\n    }\n  }\n  async play() {\n    this.core.dispatchEvent(\"play\");\n    const stoppedState = await this.init();\n    return await stoppedState.doPlay();\n  }\n  togglePlay() {\n    return this.play();\n  }\n  async seek(where) {\n    const stoppedState = await this.init();\n    return await stoppedState.seek(where);\n  }\n  async step() {\n    const stoppedState = await this.init();\n    return await stoppedState.step();\n  }\n  stop() {}\n}\nclass StoppedState extends State {\n  onEnter(_ref) {\n    let {\n      reason,\n      message\n    } = _ref;\n    this.core.dispatchEvent(\"stopped\", {\n      message\n    });\n    if (reason === \"paused\") {\n      this.core.dispatchEvent(\"pause\");\n    } else if (reason === \"ended\") {\n      this.core.dispatchEvent(\"ended\");\n    }\n  }\n  play() {\n    this.core.dispatchEvent(\"play\");\n    return this.doPlay();\n  }\n  async doPlay() {\n    const stop = await this.driver.play();\n    if (stop === true) {\n      this.core.setState(\"playing\");\n    } else if (typeof stop === \"function\") {\n      this.core.setState(\"playing\");\n      this.driver.stop = stop;\n    }\n  }\n  togglePlay() {\n    return this.play();\n  }\n  seek(where) {\n    return this.driver.seek(where);\n  }\n  step() {\n    this.driver.step();\n  }\n}\nclass PlayingState extends State {\n  onEnter() {\n    this.core.dispatchEvent(\"playing\");\n  }\n  pause() {\n    if (this.driver.pause() === true) {\n      this.core.setState(\"stopped\", {\n        reason: \"paused\"\n      });\n    }\n  }\n  togglePlay() {\n    return this.pause();\n  }\n  seek(where) {\n    return this.driver.seek(where);\n  }\n}\nclass LoadingState extends State {\n  onEnter() {\n    this.core.dispatchEvent(\"loading\");\n  }\n}\nclass OfflineState extends State {\n  onEnter() {\n    this.core.dispatchEvent(\"offline\");\n  }\n}\nclass ErroredState extends State {\n  onEnter() {\n    this.core.dispatchEvent(\"errored\");\n  }\n}\nclass Core {\n  // public\n\n  constructor(driverFn, opts) {\n    this.logger = opts.logger;\n    this.state = new UninitializedState(this);\n    this.stateName = \"uninitialized\";\n    this.driver = null;\n    this.driverFn = driverFn;\n    this.changedLines = new Set();\n    this.cursor = undefined;\n    this.duration = undefined;\n    this.cols = opts.cols;\n    this.rows = opts.rows;\n    this.speed = opts.speed ?? 1.0;\n    this.loop = opts.loop;\n    this.idleTimeLimit = opts.idleTimeLimit;\n    this.preload = opts.preload;\n    this.startAt = parseNpt(opts.startAt);\n    this.poster = this.parsePoster(opts.poster);\n    this.markers = this.normalizeMarkers(opts.markers);\n    this.pauseOnMarkers = opts.pauseOnMarkers;\n    this.commandQueue = Promise.resolve();\n    this.eventHandlers = new Map([[\"marker\", []], [\"ended\", []], [\"errored\", []], [\"init\", []], [\"input\", []], [\"loading\", []], [\"offline\", []], [\"pause\", []], [\"play\", []], [\"playing\", []], [\"reset\", []], [\"resize\", []], [\"seeked\", []], [\"stopped\", []], [\"terminalUpdate\", []]]);\n  }\n  addEventListener(eventName, handler) {\n    this.eventHandlers.get(eventName).push(handler);\n  }\n  dispatchEvent(eventName) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for (const h of this.eventHandlers.get(eventName)) {\n      h(data);\n    }\n  }\n  async init() {\n    this.wasm = await vt;\n    const feed = this.feed.bind(this);\n    const onInput = data => {\n      this.dispatchEvent(\"input\", {\n        data\n      });\n    };\n    const onMarker = _ref2 => {\n      let {\n        index,\n        time,\n        label\n      } = _ref2;\n      this.dispatchEvent(\"marker\", {\n        index,\n        time,\n        label\n      });\n    };\n    const now = this.now.bind(this);\n    const setTimeout = (f, t) => window.setTimeout(f, t / this.speed);\n    const setInterval = (f, t) => window.setInterval(f, t / this.speed);\n    const reset = this.resetVt.bind(this);\n    const setState = this.setState.bind(this);\n    const posterTime = this.poster.type === \"npt\" ? this.poster.value : undefined;\n    this.driver = this.driverFn({\n      feed,\n      onInput,\n      onMarker,\n      reset,\n      now,\n      setTimeout,\n      setInterval,\n      setState,\n      logger: this.logger\n    }, {\n      cols: this.cols,\n      rows: this.rows,\n      idleTimeLimit: this.idleTimeLimit,\n      startAt: this.startAt,\n      loop: this.loop,\n      posterTime: posterTime,\n      markers: this.markers,\n      pauseOnMarkers: this.pauseOnMarkers\n    });\n    if (typeof this.driver === \"function\") {\n      this.driver = {\n        play: this.driver\n      };\n    }\n    if (this.preload || posterTime !== undefined) {\n      this.withState(state => state.init());\n    }\n    const poster = this.poster.type === \"text\" ? this.renderPoster(this.poster.value) : undefined;\n    const config = {\n      isPausable: !!this.driver.pause,\n      isSeekable: !!this.driver.seek,\n      poster\n    };\n    if (this.driver.init === undefined) {\n      this.driver.init = () => {\n        return {};\n      };\n    }\n    if (this.driver.pause === undefined) {\n      this.driver.pause = () => {};\n    }\n    if (this.driver.seek === undefined) {\n      this.driver.seek = where => false;\n    }\n    if (this.driver.step === undefined) {\n      this.driver.step = () => {};\n    }\n    if (this.driver.stop === undefined) {\n      this.driver.stop = () => {};\n    }\n    if (this.driver.getCurrentTime === undefined) {\n      const play = this.driver.play;\n      let clock = new NullClock();\n      this.driver.play = () => {\n        clock = new Clock(this.speed);\n        return play();\n      };\n      this.driver.getCurrentTime = () => clock.getTime();\n    }\n    return config;\n  }\n  play() {\n    return this.withState(state => state.play());\n  }\n  pause() {\n    return this.withState(state => state.pause());\n  }\n  togglePlay() {\n    return this.withState(state => state.togglePlay());\n  }\n  seek(where) {\n    return this.withState(async state => {\n      if (await state.seek(where)) {\n        this.dispatchEvent(\"seeked\");\n      }\n    });\n  }\n  step() {\n    return this.withState(state => state.step());\n  }\n  stop() {\n    return this.withState(state => state.stop());\n  }\n  withState(f) {\n    return this.enqueueCommand(() => f(this.state));\n  }\n  enqueueCommand(f) {\n    this.commandQueue = this.commandQueue.then(f);\n    return this.commandQueue;\n  }\n  getChangedLines() {\n    if (this.changedLines.size > 0) {\n      const lines = new Map();\n      const rows = this.vt.rows;\n      for (const i of this.changedLines) {\n        if (i < rows) {\n          lines.set(i, {\n            id: i,\n            segments: this.vt.get_line(i)\n          });\n        }\n      }\n      this.changedLines.clear();\n      return lines;\n    }\n  }\n  getCursor() {\n    if (this.cursor === undefined && this.vt) {\n      this.cursor = this.vt.get_cursor() ?? false;\n    }\n    return this.cursor;\n  }\n  getCurrentTime() {\n    return this.driver.getCurrentTime();\n  }\n  getRemainingTime() {\n    if (typeof this.duration === \"number\") {\n      return this.duration - Math.min(this.getCurrentTime(), this.duration);\n    }\n  }\n  getProgress() {\n    if (typeof this.duration === \"number\") {\n      return Math.min(this.getCurrentTime(), this.duration) / this.duration;\n    }\n  }\n  getDuration() {\n    return this.duration;\n  }\n\n  // private\n\n  setState(newState) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.stateName === newState) return this.state;\n    this.stateName = newState;\n    if (newState === \"playing\") {\n      this.state = new PlayingState(this);\n    } else if (newState === \"stopped\") {\n      this.state = new StoppedState(this);\n    } else if (newState === \"loading\") {\n      this.state = new LoadingState(this);\n    } else if (newState === \"offline\") {\n      this.state = new OfflineState(this);\n    } else if (newState === \"errored\") {\n      this.state = new ErroredState(this);\n    } else {\n      throw `invalid state: ${newState}`;\n    }\n    this.state.onEnter(data);\n    return this.state;\n  }\n  feed(data) {\n    this.doFeed(data);\n    this.dispatchEvent(\"terminalUpdate\");\n  }\n  doFeed(data) {\n    const [affectedLines, resized] = this.vt.feed(data);\n    affectedLines.forEach(i => this.changedLines.add(i));\n    this.cursor = undefined;\n    if (resized) {\n      const [cols, rows] = this.vt.get_size();\n      this.vt.cols = cols;\n      this.vt.rows = rows;\n      this.logger.debug(`core: vt resize (${cols}x${rows})`);\n      this.dispatchEvent(\"resize\", {\n        cols,\n        rows\n      });\n    }\n  }\n  now() {\n    return performance.now() * this.speed;\n  }\n  async initializeDriver() {\n    const meta = await this.driver.init();\n    this.cols = this.cols ?? meta.cols ?? 80;\n    this.rows = this.rows ?? meta.rows ?? 24;\n    this.duration = this.duration ?? meta.duration;\n    this.markers = this.normalizeMarkers(meta.markers) ?? this.markers ?? [];\n    if (this.cols === 0) {\n      this.cols = 80;\n    }\n    if (this.rows === 0) {\n      this.rows = 24;\n    }\n    this.initializeVt(this.cols, this.rows);\n    const poster = meta.poster !== undefined ? this.renderPoster(meta.poster) : undefined;\n    this.dispatchEvent(\"init\", {\n      cols: this.cols,\n      rows: this.rows,\n      duration: this.duration,\n      markers: this.markers,\n      theme: meta.theme,\n      poster\n    });\n  }\n  resetVt(cols, rows) {\n    let init = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let theme = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    this.cols = cols;\n    this.rows = rows;\n    this.cursor = undefined;\n    this.initializeVt(cols, rows);\n    if (init !== undefined && init !== \"\") {\n      this.doFeed(init);\n    }\n    this.dispatchEvent(\"reset\", {\n      cols,\n      rows,\n      theme\n    });\n  }\n  initializeVt(cols, rows) {\n    this.logger.debug(`core: vt init (${cols}x${rows})`);\n    this.vt = this.wasm.create(cols, rows, true, 100);\n    this.vt.cols = cols;\n    this.vt.rows = rows;\n    this.changedLines.clear();\n    for (let i = 0; i < rows; i++) {\n      this.changedLines.add(i);\n    }\n  }\n  parsePoster(poster) {\n    if (typeof poster !== \"string\") return {};\n    if (poster.substring(0, 16) == \"data:text/plain,\") {\n      return {\n        type: \"text\",\n        value: [poster.substring(16)]\n      };\n    } else if (poster.substring(0, 4) == \"npt:\") {\n      return {\n        type: \"npt\",\n        value: parseNpt(poster.substring(4))\n      };\n    }\n    return {};\n  }\n  renderPoster(poster) {\n    const cols = this.cols ?? 80;\n    const rows = this.rows ?? 24;\n    this.logger.debug(`core: poster init (${cols}x${rows})`);\n    const vt = this.wasm.create(cols, rows, false, 0);\n    poster.forEach(text => vt.feed(text));\n    const cursor = vt.get_cursor() ?? false;\n    const lines = [];\n    for (let i = 0; i < rows; i++) {\n      lines.push({\n        id: i,\n        segments: vt.get_line(i)\n      });\n    }\n    return {\n      cursor,\n      lines\n    };\n  }\n  normalizeMarkers(markers) {\n    if (Array.isArray(markers)) {\n      return markers.map(m => typeof m === \"number\" ? [m, \"\"] : m);\n    }\n  }\n}\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $NAME = Symbol(\"store-name\");\nfunction wrap$1(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes) Object.defineProperty(target, $NODE, {\n    value: nodes = {}\n  });\n  return nodes;\n}\nfunction getDataNode(nodes, property, value) {\n  return nodes[property] || (nodes[property] = createDataNode(value));\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode(value) {\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return s;\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getDataNodes(target);\n    const tracked = nodes.hasOwnProperty(property);\n    let value = tracked ? nodes[property]() : target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getDataNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === \"__proto__\") return true;\n    this.get(target, property, target);\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  if (value === undefined) delete state[property];else state[property] = value;\n  let nodes = getDataNodes(state),\n    node;\n  if (node = getDataNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) (node = getDataNode(nodes, \"length\", len)) && node.$(state.length);\n  (node = nodes._) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {\n    if (target !== previous) {\n      if (property === $ROOT) return target;\n      setProperty(parent, property, target);\n    }\n    return;\n  }\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n      merge,\n      key = \"id\"\n    } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(v, {\n      [$ROOT]: state\n    }, $ROOT, merge, key);\n    return res === undefined ? state : res;\n  };\n}\n\nconst _tmpl$$8 = /*#__PURE__*/template(`<span></span>`);\nvar Segment = (props => {\n  const codePoint = () => {\n    if (props.text.length == 1) {\n      const cp = props.text.codePointAt(0);\n      if (cp >= 0x2580 && cp <= 0x259f || cp == 0xe0b0 || cp == 0xe0b2) {\n        return cp;\n      }\n    }\n  };\n  const text = () => codePoint() ? \" \" : props.text;\n  return (() => {\n    const _el$ = _tmpl$$8.cloneNode(true);\n    insert(_el$, text);\n    createRenderEffect(_p$ => {\n      const _v$ = className(props.pen, codePoint(), props.extraClass),\n        _v$2 = style(props.pen, props.offset, text().length, props.charWidth, props.terminalCols);\n      _v$ !== _p$._v$ && className$1(_el$, _p$._v$ = _v$);\n      _p$._v$2 = style$1(_el$, _v$2, _p$._v$2);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined\n    });\n    return _el$;\n  })();\n});\nfunction className(attrs, codePoint, extraClass) {\n  const fgClass = colorClass(attrs.get(\"fg\"), attrs.get(\"bold\"), \"fg-\");\n  const bgClass = colorClass(attrs.get(\"bg\"), attrs.get(\"blink\"), \"bg-\");\n  let cls = extraClass ?? \"\";\n  if (codePoint !== undefined) {\n    cls += ` cp-${codePoint.toString(16)}`;\n  }\n  if (fgClass) {\n    cls += \" \" + fgClass;\n  }\n  if (bgClass) {\n    cls += \" \" + bgClass;\n  }\n  if (attrs.has(\"bold\")) {\n    cls += \" ap-bright\";\n  }\n  if (attrs.has(\"faint\")) {\n    cls += \" ap-faint\";\n  }\n  if (attrs.has(\"italic\")) {\n    cls += \" ap-italic\";\n  }\n  if (attrs.has(\"underline\")) {\n    cls += \" ap-underline\";\n  }\n  if (attrs.has(\"blink\")) {\n    cls += \" ap-blink\";\n  }\n  if (attrs.get(\"inverse\")) {\n    cls += \" ap-inverse\";\n  }\n  return cls;\n}\nfunction colorClass(color, intense, prefix) {\n  if (typeof color === \"number\") {\n    if (intense && color < 8) {\n      color += 8;\n    }\n    return `${prefix}${color}`;\n  }\n}\nfunction style(attrs, offset, textLen, charWidth, terminalCols) {\n  const fg = attrs.get(\"fg\");\n  const bg = attrs.get(\"bg\");\n  let style = {\n    left: `${100 * offset / terminalCols}%`,\n    width: `${textLen * charWidth + 0.01}ch`\n  };\n  if (typeof fg === \"string\") {\n    style[\"--fg\"] = fg;\n  }\n  if (typeof bg === \"string\") {\n    style[\"--bg\"] = bg;\n  }\n  return style;\n}\n\nconst _tmpl$$7 = /*#__PURE__*/template(`<span class=\"ap-line\" role=\"paragraph\"></span>`);\nvar Line = (props => {\n  const segments = () => {\n    if (typeof props.cursor === \"number\") {\n      const segs = [];\n      let len = 0;\n      let i = 0;\n      while (i < props.segments.length && len + props.segments[i].text.length - 1 < props.cursor) {\n        const seg = props.segments[i];\n        segs.push(seg);\n        len += seg.text.length;\n        i++;\n      }\n      if (i < props.segments.length) {\n        const seg = props.segments[i];\n        const pos = props.cursor - len;\n        if (pos > 0) {\n          segs.push({\n            ...seg,\n            text: seg.text.substring(0, pos)\n          });\n        }\n        segs.push({\n          ...seg,\n          text: seg.text[pos],\n          offset: seg.offset + pos,\n          extraClass: \"ap-cursor\"\n        });\n        if (pos < seg.text.length - 1) {\n          segs.push({\n            ...seg,\n            text: seg.text.substring(pos + 1),\n            offset: seg.offset + pos + 1\n          });\n        }\n        i++;\n        while (i < props.segments.length) {\n          const seg = props.segments[i];\n          segs.push(seg);\n          i++;\n        }\n      }\n      return segs;\n    } else {\n      return props.segments;\n    }\n  };\n  return (() => {\n    const _el$ = _tmpl$$7.cloneNode(true);\n    insert(_el$, createComponent(Index, {\n      get each() {\n        return segments();\n      },\n      children: s => createComponent(Segment, mergeProps({\n        get terminalCols() {\n          return props.terminalCols;\n        }\n      }, s))\n    }));\n    createRenderEffect(() => _el$.style.setProperty(\"height\", props.height));\n    return _el$;\n  })();\n});\n\nconst _tmpl$$6 = /*#__PURE__*/template(`<pre class=\"ap-terminal\" aria-live=\"polite\" tabindex=\"0\"></pre>`);\nvar Terminal = (props => {\n  const lineHeight = () => props.lineHeight ?? 1.3333333333;\n  const terminalStyle = createMemo(() => {\n    return {\n      width: `${props.cols}ch`,\n      height: `${lineHeight() * props.rows}em`,\n      \"font-size\": `${(props.scale || 1.0) * 100}%`,\n      \"font-family\": props.fontFamily,\n      \"line-height\": `${lineHeight()}em`,\n      \"--term-line-height\": lineHeight()\n    };\n  });\n  const cursorCol = () => props.cursor?.[0];\n  const cursorRow = () => props.cursor?.[1];\n  return (() => {\n    const _el$ = _tmpl$$6.cloneNode(true);\n    const _ref$ = props.ref;\n    typeof _ref$ === \"function\" ? use(_ref$, _el$) : props.ref = _el$;\n    insert(_el$, createComponent(For, {\n      get each() {\n        return props.lines;\n      },\n      children: (line, i) => createComponent(Line, {\n        get segments() {\n          return line.segments;\n        },\n        get cursor() {\n          return createMemo(() => i() === cursorRow())() ? cursorCol() : null;\n        },\n        get height() {\n          return `${lineHeight()}em`;\n        },\n        get terminalCols() {\n          return props.cols;\n        }\n      })\n    }));\n    createRenderEffect(_p$ => {\n      const _v$ = !!(props.blink || props.cursorHold),\n        _v$2 = !!props.blink,\n        _v$3 = terminalStyle();\n      _v$ !== _p$._v$ && _el$.classList.toggle(\"ap-cursor-on\", _p$._v$ = _v$);\n      _v$2 !== _p$._v$2 && _el$.classList.toggle(\"ap-blink\", _p$._v$2 = _v$2);\n      _p$._v$3 = style$1(_el$, _v$3, _p$._v$3);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined,\n      _v$3: undefined\n    });\n    return _el$;\n  })();\n});\n\nconst _tmpl$$5 = /*#__PURE__*/template(`<svg version=\"1.1\" viewBox=\"0 0 12 12\" class=\"ap-icon\" aria-label=\"Pause\" role=\"button\" tabindex=\"0\"><path d=\"M1,0 L4,0 L4,12 L1,12 Z\"></path><path d=\"M8,0 L11,0 L11,12 L8,12 Z\"></path></svg>`),\n  _tmpl$2 = /*#__PURE__*/template(`<svg version=\"1.1\" viewBox=\"0 0 12 12\" class=\"ap-icon\" aria-label=\"Play\" role=\"button\" tabindex=\"0\"><path d=\"M1,0 L11,6 L1,12 Z\"></path></svg>`),\n  _tmpl$3 = /*#__PURE__*/template(`<span class=\"ap-playback-button\"></span>`),\n  _tmpl$4 = /*#__PURE__*/template(`<span class=\"ap-progressbar\"><span class=\"ap-bar\"><span class=\"ap-gutter\"><span class=\"ap-gutter-fill\"></span></span></span></span>`),\n  _tmpl$5 = /*#__PURE__*/template(`<div class=\"ap-control-bar\"><span class=\"ap-timer\" aria-readonly=\"true\" role=\"textbox\" tabindex=\"0\"><span class=\"ap-time-elapsed\"></span><span class=\"ap-time-remaining\"></span></span><span class=\"ap-fullscreen-button\" title=\"Toggle fullscreen mode\" aria-label=\"Toggle Fullscreen\" role=\"button\" tabindex=\"0\"><svg version=\"1.1\" viewBox=\"0 0 12 12\" class=\"ap-icon\"><path d=\"M12,0 L7,0 L9,2 L7,4 L8,5 L10,3 L12,5 Z\"></path><path d=\"M0,12 L0,7 L2,9 L4,7 L5,8 L3,10 L5,12 Z\"></path></svg><svg version=\"1.1\" viewBox=\"0 0 12 12\" class=\"ap-icon\"><path d=\"M7,5 L7,0 L9,2 L11,0 L12,1 L10,3 L12,5 Z\"></path><path d=\"M5,7 L0,7 L2,9 L0,11 L1,12 L3,10 L5,12 Z\"></path></svg></span></div>`),\n  _tmpl$6 = /*#__PURE__*/template(`<span class=\"ap-marker-container\"><span class=\"ap-marker\"></span><span class=\"ap-marker-tooltip\"></span></span>`);\nfunction formatTime(seconds) {\n  let s = Math.floor(seconds);\n  const d = Math.floor(s / 86400);\n  s %= 86400;\n  const h = Math.floor(s / 3600);\n  s %= 3600;\n  const m = Math.floor(s / 60);\n  s %= 60;\n  if (d > 0) {\n    return `${zeroPad(d)}:${zeroPad(h)}:${zeroPad(m)}:${zeroPad(s)}`;\n  } else if (h > 0) {\n    return `${zeroPad(h)}:${zeroPad(m)}:${zeroPad(s)}`;\n  } else {\n    return `${zeroPad(m)}:${zeroPad(s)}`;\n  }\n}\nfunction zeroPad(n) {\n  return n < 10 ? `0${n}` : n.toString();\n}\nvar ControlBar = (props => {\n  const e = f => {\n    return e => {\n      e.preventDefault();\n      f(e);\n    };\n  };\n  const currentTime = () => typeof props.currentTime === \"number\" ? formatTime(props.currentTime) : \"--:--\";\n  const remainingTime = () => typeof props.remainingTime === \"number\" ? \"-\" + formatTime(props.remainingTime) : currentTime();\n  const markers = createMemo(() => typeof props.duration === \"number\" ? props.markers.filter(m => m[0] < props.duration) : []);\n  const markerPosition = m => `${m[0] / props.duration * 100}%`;\n  const markerText = m => {\n    if (m[1] === \"\") {\n      return formatTime(m[0]);\n    } else {\n      return `${formatTime(m[0])} - ${m[1]}`;\n    }\n  };\n  const isPastMarker = m => typeof props.currentTime === \"number\" ? m[0] <= props.currentTime : false;\n  const gutterBarStyle = () => {\n    return {\n      width: \"100%\",\n      transform: `scaleX(${props.progress || 0}`,\n      \"transform-origin\": \"left center\"\n    };\n  };\n  const calcPosition = e => {\n    const barWidth = e.currentTarget.offsetWidth;\n    const rect = e.currentTarget.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const pos = Math.max(0, mouseX / barWidth);\n    return `${pos * 100}%`;\n  };\n  const [mouseDown, setMouseDown] = createSignal(false);\n  const throttledSeek = throttle(props.onSeekClick, 50);\n  const onClick = e => {\n    if (e.altKey || e.shiftKey || e.metaKey || e.ctrlKey || e.button !== 0) return;\n    setMouseDown(true);\n    props.onSeekClick(calcPosition(e));\n  };\n  const seekToMarker = index => {\n    return e(() => {\n      props.onSeekClick({\n        marker: index\n      });\n    });\n  };\n  const onMove = e => {\n    if (e.altKey || e.shiftKey || e.metaKey || e.ctrlKey) return;\n    if (mouseDown()) {\n      throttledSeek(calcPosition(e));\n    }\n  };\n  const onDocumentMouseUp = () => {\n    setMouseDown(false);\n  };\n  const stopPropagation = e(e => {\n    e.stopPropagation();\n  });\n  document.addEventListener(\"mouseup\", onDocumentMouseUp);\n  onCleanup(() => {\n    document.removeEventListener(\"mouseup\", onDocumentMouseUp);\n  });\n  return (() => {\n    const _el$ = _tmpl$5.cloneNode(true),\n      _el$5 = _el$.firstChild,\n      _el$6 = _el$5.firstChild,\n      _el$7 = _el$6.nextSibling,\n      _el$12 = _el$5.nextSibling;\n    const _ref$ = props.ref;\n    typeof _ref$ === \"function\" ? use(_ref$, _el$) : props.ref = _el$;\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return props.isPausable;\n      },\n      get children() {\n        const _el$2 = _tmpl$3.cloneNode(true);\n        addEventListener(_el$2, \"click\", e(props.onPlayClick), true);\n        insert(_el$2, createComponent(Switch, {\n          get children() {\n            return [createComponent(Match, {\n              get when() {\n                return props.isPlaying;\n              },\n              get children() {\n                return _tmpl$$5.cloneNode(true);\n              }\n            }), createComponent(Match, {\n              get when() {\n                return !props.isPlaying;\n              },\n              get children() {\n                return _tmpl$2.cloneNode(true);\n              }\n            })];\n          }\n        }));\n        return _el$2;\n      }\n    }), _el$5);\n    insert(_el$6, currentTime);\n    insert(_el$7, remainingTime);\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return typeof props.progress === \"number\" || props.isSeekable;\n      },\n      get children() {\n        const _el$8 = _tmpl$4.cloneNode(true),\n          _el$9 = _el$8.firstChild,\n          _el$10 = _el$9.firstChild,\n          _el$11 = _el$10.firstChild;\n        _el$9.$$mousemove = onMove;\n        _el$9.$$mousedown = onClick;\n        insert(_el$9, createComponent(For, {\n          get each() {\n            return markers();\n          },\n          children: (m, i) => (() => {\n            const _el$13 = _tmpl$6.cloneNode(true),\n              _el$14 = _el$13.firstChild,\n              _el$15 = _el$14.nextSibling;\n            addEventListener(_el$13, \"mousedown\", stopPropagation, true);\n            addEventListener(_el$13, \"click\", seekToMarker(i()), true);\n            insert(_el$15, () => markerText(m));\n            createRenderEffect(_p$ => {\n              const _v$ = markerPosition(m),\n                _v$2 = !!isPastMarker(m);\n              _v$ !== _p$._v$ && _el$13.style.setProperty(\"left\", _p$._v$ = _v$);\n              _v$2 !== _p$._v$2 && _el$14.classList.toggle(\"ap-marker-past\", _p$._v$2 = _v$2);\n              return _p$;\n            }, {\n              _v$: undefined,\n              _v$2: undefined\n            });\n            return _el$13;\n          })()\n        }), null);\n        createRenderEffect(_$p => style$1(_el$11, gutterBarStyle(), _$p));\n        return _el$8;\n      }\n    }), _el$12);\n    addEventListener(_el$12, \"click\", e(props.onFullscreenClick), true);\n    createRenderEffect(() => _el$.classList.toggle(\"ap-seekable\", !!props.isSeekable));\n    return _el$;\n  })();\n});\ndelegateEvents([\"click\", \"mousedown\", \"mousemove\"]);\n\nconst _tmpl$$4 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-error\"><span></span></div>`);\nvar ErrorOverlay = (props => {\n  return _tmpl$$4.cloneNode(true);\n});\n\nconst _tmpl$$3 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-loading\"><span class=\"ap-loader\"></span></div>`);\nvar LoaderOverlay = (props => {\n  return _tmpl$$3.cloneNode(true);\n});\n\nconst _tmpl$$2 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-info\"><span></span></div>`);\nvar InfoOverlay = (props => {\n  const style = () => {\n    return {\n      \"font-family\": props.fontFamily\n    };\n  };\n  return (() => {\n    const _el$ = _tmpl$$2.cloneNode(true),\n      _el$2 = _el$.firstChild;\n    insert(_el$2, () => props.message);\n    createRenderEffect(_$p => style$1(_el$2, style(), _$p));\n    return _el$;\n  })();\n});\n\nconst _tmpl$$1 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-start\"><div class=\"ap-play-button\"><div><span><svg version=\"1.1\" viewBox=\"0 0 1000.0 1000.0\" class=\"ap-icon\"><defs><mask id=\"small-triangle-mask\"><rect width=\"100%\" height=\"100%\" fill=\"white\"></rect><polygon points=\"700.0 500.0, 400.00000000000006 326.7949192431122, 399.9999999999999 673.2050807568877\" fill=\"black\"></polygon></mask></defs><polygon points=\"1000.0 500.0, 250.0000000000001 66.98729810778059, 249.99999999999977 933.0127018922192\" mask=\"url(#small-triangle-mask)\" fill=\"white\" class=\"ap-play-btn-fill\"></polygon><polyline points=\"673.2050807568878 400.0, 326.7949192431123 600.0\" stroke=\"white\" stroke-width=\"90\" class=\"ap-play-btn-stroke\"></polyline></svg></span></div></div></div>`);\nvar StartOverlay = (props => {\n  const e = f => {\n    return e => {\n      e.preventDefault();\n      f(e);\n    };\n  };\n  return (() => {\n    const _el$ = _tmpl$$1.cloneNode(true);\n    addEventListener(_el$, \"click\", e(props.onClick), true);\n    return _el$;\n  })();\n});\ndelegateEvents([\"click\"]);\n\nconst _tmpl$ = /*#__PURE__*/template(`<div class=\"ap-wrapper\" tabindex=\"-1\"><div></div></div>`);\nconst CONTROL_BAR_HEIGHT = 32; // must match height of div.ap-control-bar in CSS\n\nvar Player = (props => {\n  const logger = props.logger;\n  const core = props.core;\n  const autoPlay = props.autoPlay;\n  const [state, setState] = createStore({\n    lines: [],\n    cursor: undefined,\n    charW: props.charW,\n    charH: props.charH,\n    bordersW: props.bordersW,\n    bordersH: props.bordersH,\n    containerW: 0,\n    containerH: 0,\n    isPausable: true,\n    isSeekable: true,\n    isFullscreen: false,\n    currentTime: null,\n    remainingTime: null,\n    progress: null,\n    blink: true,\n    cursorHold: false\n  });\n  const [isPlaying, setIsPlaying] = createSignal(false);\n  const [overlay, setOverlay] = createSignal(!autoPlay ? \"start\" : null);\n  const [infoMessage, setInfoMessage] = createSignal(null);\n  const [terminalSize, setTerminalSize] = createSignal({\n    cols: props.cols,\n    rows: props.rows\n  });\n  const [duration, setDuration] = createSignal(undefined);\n  const [markers, setMarkers] = createStore([]);\n  const [userActive, setUserActive] = createSignal(false);\n  const [originalTheme, setOriginalTheme] = createSignal(undefined);\n  const terminalCols = () => terminalSize().cols || 80;\n  const terminalRows = () => terminalSize().rows || 24;\n  const controlBarHeight = () => props.controls === false ? 0 : CONTROL_BAR_HEIGHT;\n  const controlsVisible = () => props.controls === true || props.controls === \"auto\" && userActive();\n  let frameRequestId;\n  let userActivityTimeoutId;\n  let timeUpdateIntervalId;\n  let blinkIntervalId;\n  let wrapperRef;\n  let playerRef;\n  let terminalRef;\n  let controlBarRef;\n  let resizeObserver;\n  function onPlaying() {\n    updateTerminal();\n    startBlinking();\n    startTimeUpdates();\n  }\n  function onStopped() {\n    stopBlinking();\n    stopTimeUpdates();\n    updateTime();\n  }\n  function resize(size_) {\n    batch(() => {\n      if (size_.rows < terminalSize().rows) {\n        setState(\"lines\", state.lines.slice(0, size_.rows));\n      }\n      setTerminalSize(size_);\n    });\n  }\n  function setPoster(poster) {\n    if (poster !== undefined && !autoPlay) {\n      setState({\n        lines: poster.lines,\n        cursor: poster.cursor\n      });\n    }\n  }\n  core.addEventListener(\"init\", _ref => {\n    let {\n      cols,\n      rows,\n      duration,\n      theme,\n      poster,\n      markers\n    } = _ref;\n    batch(() => {\n      resize({\n        cols,\n        rows\n      });\n      setDuration(duration);\n      setOriginalTheme(theme);\n      setMarkers(markers);\n      setPoster(poster);\n    });\n  });\n  core.addEventListener(\"play\", () => {\n    setOverlay(null);\n  });\n  core.addEventListener(\"playing\", () => {\n    batch(() => {\n      setIsPlaying(true);\n      setOverlay(null);\n      onPlaying();\n    });\n  });\n  core.addEventListener(\"stopped\", _ref2 => {\n    let {\n      message\n    } = _ref2;\n    batch(() => {\n      setIsPlaying(false);\n      onStopped();\n      if (message !== undefined) {\n        setInfoMessage(message);\n        setOverlay(\"info\");\n      }\n    });\n  });\n  core.addEventListener(\"loading\", () => {\n    batch(() => {\n      setIsPlaying(false);\n      onStopped();\n      setOverlay(\"loader\");\n    });\n  });\n  core.addEventListener(\"offline\", () => {\n    batch(() => {\n      setIsPlaying(false);\n      onStopped();\n      setInfoMessage(\"Stream offline\");\n      setOverlay(\"info\");\n    });\n  });\n  core.addEventListener(\"errored\", () => {\n    setOverlay(\"error\");\n  });\n  core.addEventListener(\"resize\", resize);\n  core.addEventListener(\"reset\", _ref3 => {\n    let {\n      cols,\n      rows,\n      theme\n    } = _ref3;\n    batch(() => {\n      resize({\n        cols,\n        rows\n      });\n      setOriginalTheme(theme);\n      updateTerminal();\n    });\n  });\n  core.addEventListener(\"seeked\", () => {\n    updateTime();\n  });\n  core.addEventListener(\"terminalUpdate\", () => {\n    if (frameRequestId === undefined) {\n      frameRequestId = requestAnimationFrame(updateTerminal);\n    }\n  });\n  const setupResizeObserver = () => {\n    resizeObserver = new ResizeObserver(debounce(_entries => {\n      setState({\n        containerW: wrapperRef.offsetWidth,\n        containerH: wrapperRef.offsetHeight\n      });\n      wrapperRef.dispatchEvent(new CustomEvent(\"resize\", {\n        detail: {\n          el: playerRef\n        }\n      }));\n    }, 10));\n    resizeObserver.observe(wrapperRef);\n  };\n  onMount(async () => {\n    logger.info(\"player mounted\");\n    logger.debug(\"font measurements\", {\n      charW: state.charW,\n      charH: state.charH\n    });\n    setupResizeObserver();\n    const {\n      isPausable,\n      isSeekable,\n      poster\n    } = await core.init();\n    batch(() => {\n      setState({\n        isPausable,\n        isSeekable,\n        containerW: wrapperRef.offsetWidth,\n        containerH: wrapperRef.offsetHeight\n      });\n      setPoster(poster);\n    });\n    if (autoPlay) {\n      core.play();\n    }\n  });\n  onCleanup(() => {\n    core.stop();\n    stopBlinking();\n    stopTimeUpdates();\n    resizeObserver.disconnect();\n  });\n  const updateTerminal = () => {\n    const changedLines = core.getChangedLines();\n    batch(() => {\n      if (changedLines) {\n        changedLines.forEach((line, i) => {\n          setState(\"lines\", i, reconcile(line));\n        });\n      }\n      setState(\"cursor\", reconcile(core.getCursor()));\n      setState(\"cursorHold\", true);\n    });\n    frameRequestId = undefined;\n  };\n  const terminalElementSize = createMemo(() => {\n    logger.debug(`containerW = ${state.containerW}`);\n    const terminalW = state.charW * terminalCols() + state.bordersW;\n    const terminalH = state.charH * terminalRows() + state.bordersH;\n    let fit = props.fit ?? \"width\";\n    if (fit === \"both\" || state.isFullscreen) {\n      const containerRatio = state.containerW / (state.containerH - controlBarHeight());\n      const terminalRatio = terminalW / terminalH;\n      if (containerRatio > terminalRatio) {\n        fit = \"height\";\n      } else {\n        fit = \"width\";\n      }\n    }\n    if (fit === false || fit === \"none\") {\n      return {};\n    } else if (fit === \"width\") {\n      const scale = state.containerW / terminalW;\n      return {\n        scale: scale,\n        width: state.containerW,\n        height: terminalH * scale + controlBarHeight()\n      };\n    } else if (fit === \"height\") {\n      const scale = (state.containerH - controlBarHeight()) / terminalH;\n      return {\n        scale: scale,\n        width: terminalW * scale,\n        height: state.containerH\n      };\n    } else {\n      throw `unsupported fit mode: ${fit}`;\n    }\n  });\n  const onFullscreenChange = () => {\n    setState(\"isFullscreen\", document.fullscreenElement ?? document.webkitFullscreenElement);\n  };\n  const toggleFullscreen = () => {\n    if (state.isFullscreen) {\n      (document.exitFullscreen ?? document.webkitExitFullscreen ?? (() => {})).apply(document);\n    } else {\n      (wrapperRef.requestFullscreen ?? wrapperRef.webkitRequestFullscreen ?? (() => {})).apply(wrapperRef);\n    }\n  };\n  const onKeyPress = e => {\n    if (e.altKey || e.metaKey || e.ctrlKey) {\n      return;\n    }\n    if (e.shiftKey) {\n      if (e.key == \"ArrowLeft\") {\n        core.seek(\"<<<\");\n      } else if (e.key == \"ArrowRight\") {\n        core.seek(\">>>\");\n      } else {\n        return;\n      }\n      e.stopPropagation();\n      e.preventDefault();\n      return;\n    }\n    if (e.key == \" \") {\n      core.togglePlay();\n    } else if (e.key == \".\") {\n      core.step();\n      updateTime();\n    } else if (e.key == \"f\") {\n      toggleFullscreen();\n    } else if (e.key == \"ArrowLeft\") {\n      core.seek(\"<<\");\n    } else if (e.key == \"ArrowRight\") {\n      core.seek(\">>\");\n    } else if (e.key == \"[\") {\n      core.seek({\n        marker: \"prev\"\n      });\n    } else if (e.key == \"]\") {\n      core.seek({\n        marker: \"next\"\n      });\n    } else if (e.key.charCodeAt(0) >= 48 && e.key.charCodeAt(0) <= 57) {\n      const pos = (e.key.charCodeAt(0) - 48) / 10;\n      core.seek(`${pos * 100}%`);\n    } else {\n      return;\n    }\n    e.stopPropagation();\n    e.preventDefault();\n  };\n  const wrapperOnMouseMove = () => {\n    if (state.isFullscreen) {\n      onUserActive(true);\n    }\n  };\n  const playerOnMouseLeave = () => {\n    if (!state.isFullscreen) {\n      onUserActive(false);\n    }\n  };\n  const startTimeUpdates = () => {\n    timeUpdateIntervalId = setInterval(updateTime, 100);\n  };\n  const stopTimeUpdates = () => {\n    clearInterval(timeUpdateIntervalId);\n  };\n  const updateTime = () => {\n    const currentTime = core.getCurrentTime();\n    const remainingTime = core.getRemainingTime();\n    const progress = core.getProgress();\n    setState({\n      currentTime,\n      remainingTime,\n      progress\n    });\n  };\n  const startBlinking = () => {\n    blinkIntervalId = setInterval(() => {\n      setState(state => {\n        const changes = {\n          blink: !state.blink\n        };\n        if (changes.blink) {\n          changes.cursorHold = false;\n        }\n        return changes;\n      });\n    }, 500);\n  };\n  const stopBlinking = () => {\n    clearInterval(blinkIntervalId);\n    setState(\"blink\", true);\n  };\n  const onUserActive = show => {\n    clearTimeout(userActivityTimeoutId);\n    if (show) {\n      userActivityTimeoutId = setTimeout(() => onUserActive(false), 2000);\n    }\n    setUserActive(show);\n  };\n  const playerStyle = () => {\n    const style = {};\n    if ((props.fit === false || props.fit === \"none\") && props.terminalFontSize !== undefined) {\n      if (props.terminalFontSize === \"small\") {\n        style[\"font-size\"] = \"12px\";\n      } else if (props.terminalFontSize === \"medium\") {\n        style[\"font-size\"] = \"18px\";\n      } else if (props.terminalFontSize === \"big\") {\n        style[\"font-size\"] = \"24px\";\n      } else {\n        style[\"font-size\"] = props.terminalFontSize;\n      }\n    }\n    const size = terminalElementSize();\n    if (size.width !== undefined) {\n      style[\"width\"] = `${size.width}px`;\n      style[\"height\"] = `${size.height}px`;\n    }\n    const theme = originalTheme();\n    if (theme !== undefined && (props.theme === undefined || props.theme === null)) {\n      style[\"--term-color-foreground\"] = theme.foreground;\n      style[\"--term-color-background\"] = theme.background;\n      theme.palette.forEach((color, i) => {\n        style[`--term-color-${i}`] = color;\n      });\n    }\n    return style;\n  };\n  const playerClass = () => `ap-player asciinema-player-theme-${props.theme ?? \"asciinema\"}`;\n  const terminalScale = () => terminalElementSize()?.scale;\n  const el = (() => {\n    const _el$ = _tmpl$.cloneNode(true),\n      _el$2 = _el$.firstChild;\n    const _ref$ = wrapperRef;\n    typeof _ref$ === \"function\" ? use(_ref$, _el$) : wrapperRef = _el$;\n    _el$.addEventListener(\"webkitfullscreenchange\", onFullscreenChange);\n    _el$.addEventListener(\"fullscreenchange\", onFullscreenChange);\n    _el$.$$mousemove = wrapperOnMouseMove;\n    _el$.$$keydown = onKeyPress;\n    _el$.addEventListener(\"keypress\", onKeyPress);\n    const _ref$2 = playerRef;\n    typeof _ref$2 === \"function\" ? use(_ref$2, _el$2) : playerRef = _el$2;\n    _el$2.$$mousemove = () => onUserActive(true);\n    _el$2.addEventListener(\"mouseleave\", playerOnMouseLeave);\n    insert(_el$2, createComponent(Terminal, {\n      get cols() {\n        return terminalCols();\n      },\n      get rows() {\n        return terminalRows();\n      },\n      get scale() {\n        return terminalScale();\n      },\n      get blink() {\n        return state.blink;\n      },\n      get lines() {\n        return state.lines;\n      },\n      get cursor() {\n        return state.cursor;\n      },\n      get cursorHold() {\n        return state.cursorHold;\n      },\n      get fontFamily() {\n        return props.terminalFontFamily;\n      },\n      get lineHeight() {\n        return props.terminalLineHeight;\n      },\n      ref(r$) {\n        const _ref$3 = terminalRef;\n        typeof _ref$3 === \"function\" ? _ref$3(r$) : terminalRef = r$;\n      }\n    }), null);\n    insert(_el$2, createComponent(Show, {\n      get when() {\n        return props.controls !== false;\n      },\n      get children() {\n        return createComponent(ControlBar, {\n          get duration() {\n            return duration();\n          },\n          get currentTime() {\n            return state.currentTime;\n          },\n          get remainingTime() {\n            return state.remainingTime;\n          },\n          get progress() {\n            return state.progress;\n          },\n          markers: markers,\n          get isPlaying() {\n            return isPlaying();\n          },\n          get isPausable() {\n            return state.isPausable;\n          },\n          get isSeekable() {\n            return state.isSeekable;\n          },\n          onPlayClick: () => core.togglePlay(),\n          onFullscreenClick: toggleFullscreen,\n          onSeekClick: pos => core.seek(pos),\n          ref(r$) {\n            const _ref$4 = controlBarRef;\n            typeof _ref$4 === \"function\" ? _ref$4(r$) : controlBarRef = r$;\n          }\n        });\n      }\n    }), null);\n    insert(_el$2, createComponent(Switch, {\n      get children() {\n        return [createComponent(Match, {\n          get when() {\n            return overlay() == \"start\";\n          },\n          get children() {\n            return createComponent(StartOverlay, {\n              onClick: () => core.play()\n            });\n          }\n        }), createComponent(Match, {\n          get when() {\n            return overlay() == \"loader\";\n          },\n          get children() {\n            return createComponent(LoaderOverlay, {});\n          }\n        }), createComponent(Match, {\n          get when() {\n            return overlay() == \"info\";\n          },\n          get children() {\n            return createComponent(InfoOverlay, {\n              get message() {\n                return infoMessage();\n              },\n              get fontFamily() {\n                return props.terminalFontFamily;\n              }\n            });\n          }\n        }), createComponent(Match, {\n          get when() {\n            return overlay() == \"error\";\n          },\n          get children() {\n            return createComponent(ErrorOverlay, {});\n          }\n        })];\n      }\n    }), null);\n    createRenderEffect(_p$ => {\n      const _v$ = !!controlsVisible(),\n        _v$2 = playerClass(),\n        _v$3 = playerStyle();\n      _v$ !== _p$._v$ && _el$.classList.toggle(\"ap-hud\", _p$._v$ = _v$);\n      _v$2 !== _p$._v$2 && className$1(_el$2, _p$._v$2 = _v$2);\n      _p$._v$3 = style$1(_el$2, _v$3, _p$._v$3);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined,\n      _v$3: undefined\n    });\n    return _el$;\n  })();\n  return el;\n});\ndelegateEvents([\"keydown\", \"mousemove\"]);\n\nclass DummyLogger {\n  log() {}\n  debug() {}\n  info() {}\n  warn() {}\n  error() {}\n}\nclass PrefixedLogger {\n  constructor(logger, prefix) {\n    this.logger = logger;\n    this.prefix = prefix;\n  }\n  log(message) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    this.logger.log(`${this.prefix}${message}`, ...args);\n  }\n  debug(message) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    this.logger.debug(`${this.prefix}${message}`, ...args);\n  }\n  info(message) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    this.logger.info(`${this.prefix}${message}`, ...args);\n  }\n  warn(message) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    this.logger.warn(`${this.prefix}${message}`, ...args);\n  }\n  error(message) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    this.logger.error(`${this.prefix}${message}`, ...args);\n  }\n}\n\n// Efficient array transformations without intermediate array objects.\n// Inspired by Elixir's streams and Rust's iterator adapters.\n\nclass Stream {\n  constructor(input, xfs) {\n    this.input = typeof input.next === \"function\" ? input : input[Symbol.iterator]();\n    this.xfs = xfs ?? [];\n  }\n  map(f) {\n    return this.transform(Map$1(f));\n  }\n  flatMap(f) {\n    return this.transform(FlatMap(f));\n  }\n  filter(f) {\n    return this.transform(Filter(f));\n  }\n  take(n) {\n    return this.transform(Take(n));\n  }\n  drop(n) {\n    return this.transform(Drop(n));\n  }\n  transform(f) {\n    return new Stream(this.input, this.xfs.concat([f]));\n  }\n  multiplex(other, comparator) {\n    return new Stream(new Multiplexer(this[Symbol.iterator](), other[Symbol.iterator](), comparator));\n  }\n  toArray() {\n    return Array.from(this);\n  }\n  [Symbol.iterator]() {\n    let v = 0;\n    let values = [];\n    let flushed = false;\n    const xf = compose(this.xfs, val => values.push(val));\n    return {\n      next: () => {\n        if (v === values.length) {\n          values = [];\n          v = 0;\n        }\n        while (values.length === 0) {\n          const next = this.input.next();\n          if (next.done) {\n            break;\n          } else {\n            xf.step(next.value);\n          }\n        }\n        if (values.length === 0 && !flushed) {\n          xf.flush();\n          flushed = true;\n        }\n        if (values.length > 0) {\n          return {\n            done: false,\n            value: values[v++]\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  }\n}\nfunction Map$1(f) {\n  return emit => {\n    return input => {\n      emit(f(input));\n    };\n  };\n}\nfunction FlatMap(f) {\n  return emit => {\n    return input => {\n      f(input).forEach(emit);\n    };\n  };\n}\nfunction Filter(f) {\n  return emit => {\n    return input => {\n      if (f(input)) {\n        emit(input);\n      }\n    };\n  };\n}\nfunction Take(n) {\n  let c = 0;\n  return emit => {\n    return input => {\n      if (c < n) {\n        emit(input);\n      }\n      c += 1;\n    };\n  };\n}\nfunction Drop(n) {\n  let c = 0;\n  return emit => {\n    return input => {\n      c += 1;\n      if (c > n) {\n        emit(input);\n      }\n    };\n  };\n}\nfunction compose(xfs, push) {\n  return xfs.reverse().reduce((next, curr) => {\n    const xf = toXf(curr(next.step));\n    return {\n      step: xf.step,\n      flush: () => {\n        xf.flush();\n        next.flush();\n      }\n    };\n  }, toXf(push));\n}\nfunction toXf(xf) {\n  if (typeof xf === \"function\") {\n    return {\n      step: xf,\n      flush: () => {}\n    };\n  } else {\n    return xf;\n  }\n}\nclass Multiplexer {\n  constructor(left, right, comparator) {\n    this.left = left;\n    this.right = right;\n    this.comparator = comparator;\n  }\n  [Symbol.iterator]() {\n    let leftItem;\n    let rightItem;\n    return {\n      next: () => {\n        if (leftItem === undefined && this.left !== undefined) {\n          const result = this.left.next();\n          if (result.done) {\n            this.left = undefined;\n          } else {\n            leftItem = result.value;\n          }\n        }\n        if (rightItem === undefined && this.right !== undefined) {\n          const result = this.right.next();\n          if (result.done) {\n            this.right = undefined;\n          } else {\n            rightItem = result.value;\n          }\n        }\n        if (leftItem === undefined && rightItem === undefined) {\n          return {\n            done: true\n          };\n        } else if (leftItem === undefined) {\n          const value = rightItem;\n          rightItem = undefined;\n          return {\n            done: false,\n            value: value\n          };\n        } else if (rightItem === undefined) {\n          const value = leftItem;\n          leftItem = undefined;\n          return {\n            done: false,\n            value: value\n          };\n        } else if (this.comparator(leftItem, rightItem)) {\n          const value = leftItem;\n          leftItem = undefined;\n          return {\n            done: false,\n            value: value\n          };\n        } else {\n          const value = rightItem;\n          rightItem = undefined;\n          return {\n            done: false,\n            value: value\n          };\n        }\n      }\n    };\n  }\n}\n\nasync function parse$2(data) {\n  let header;\n  let events;\n  if (data instanceof Response) {\n    const text = await data.text();\n    const result = parseJsonl(text);\n    if (result !== undefined) {\n      header = result.header;\n      events = result.events;\n    } else {\n      header = JSON.parse(text);\n    }\n  } else if (typeof data === \"object\" && typeof data.version === \"number\") {\n    header = data;\n  } else if (Array.isArray(data)) {\n    header = data[0];\n    events = data.slice(1, data.length);\n  } else {\n    throw \"invalid data\";\n  }\n  if (header.version === 1) {\n    return parseAsciicastV1(header);\n  } else if (header.version === 2) {\n    return parseAsciicastV2(header, events);\n  } else {\n    throw `asciicast v${header.version} format not supported`;\n  }\n}\nfunction parseJsonl(jsonl) {\n  const lines = jsonl.split(\"\\n\");\n  let header;\n  try {\n    header = JSON.parse(lines[0]);\n  } catch (_error) {\n    return;\n  }\n  const events = new Stream(lines).drop(1).filter(l => l[0] === \"[\").map(JSON.parse).toArray();\n  return {\n    header,\n    events\n  };\n}\nfunction parseAsciicastV1(data) {\n  let time = 0;\n  const events = new Stream(data.stdout).map(e => {\n    time += e[0];\n    return [time, \"o\", e[1]];\n  });\n  return {\n    cols: data.width,\n    rows: data.height,\n    events\n  };\n}\nfunction parseAsciicastV2(header, events) {\n  return {\n    cols: header.width,\n    rows: header.height,\n    theme: parseTheme(header.theme),\n    events,\n    idleTimeLimit: header.idle_time_limit\n  };\n}\nfunction parseTheme(theme) {\n  const colorRegex = /^#[0-9A-Fa-f]{6}$/;\n  const paletteRegex = /^(#[0-9A-Fa-f]{6}:){7,}#[0-9A-Fa-f]{6}$/;\n  const fg = theme?.fg;\n  const bg = theme?.bg;\n  const palette = theme?.palette;\n  if (colorRegex.test(fg) && colorRegex.test(bg) && paletteRegex.test(palette)) {\n    return {\n      foreground: fg,\n      background: bg,\n      palette: palette.split(\":\")\n    };\n  }\n}\nfunction unparseAsciicastV2(recording) {\n  const header = JSON.stringify({\n    version: 2,\n    width: recording.cols,\n    height: recording.rows\n  });\n  const events = recording.events.map(JSON.stringify).join(\"\\n\");\n  return `${header}\\n${events}\\n`;\n}\n\nfunction recording(src, _ref, _ref2) {\n  let {\n    feed,\n    onInput,\n    onMarker,\n    now,\n    setTimeout,\n    setState,\n    logger\n  } = _ref;\n  let {\n    idleTimeLimit,\n    startAt,\n    loop,\n    posterTime,\n    markers: markers_,\n    pauseOnMarkers,\n    cols: initialCols,\n    rows: initialRows\n  } = _ref2;\n  let cols;\n  let rows;\n  let events;\n  let markers;\n  let duration;\n  let effectiveStartAt;\n  let eventTimeoutId;\n  let nextEventIndex = 0;\n  let lastEventTime = 0;\n  let startTime;\n  let pauseElapsedTime;\n  let playCount = 0;\n  async function init() {\n    const {\n      parser,\n      minFrameTime,\n      inputOffset,\n      dumpFilename,\n      encoding = \"utf-8\"\n    } = src;\n    const recording = prepare(await parser(await doFetch(src), {\n      encoding\n    }), logger, {\n      idleTimeLimit,\n      startAt,\n      minFrameTime,\n      inputOffset,\n      markers_\n    });\n    ({\n      cols,\n      rows,\n      events,\n      duration,\n      effectiveStartAt\n    } = recording);\n    initialCols = initialCols ?? cols;\n    initialRows = initialRows ?? rows;\n    if (events.length === 0) {\n      throw \"recording is missing events\";\n    }\n    if (dumpFilename !== undefined) {\n      dump(recording, dumpFilename);\n    }\n    const poster = posterTime !== undefined ? getPoster(posterTime) : undefined;\n    markers = events.filter(e => e[1] === \"m\").map(e => [e[0], e[2].label]);\n    return {\n      cols,\n      rows,\n      duration,\n      theme: recording.theme,\n      poster,\n      markers\n    };\n  }\n  function doFetch(_ref3) {\n    let {\n      url,\n      data,\n      fetchOpts = {}\n    } = _ref3;\n    if (typeof url === \"string\") {\n      return doFetchOne(url, fetchOpts);\n    } else if (Array.isArray(url)) {\n      return Promise.all(url.map(url => doFetchOne(url, fetchOpts)));\n    } else if (data !== undefined) {\n      if (typeof data === \"function\") {\n        data = data();\n      }\n      if (!(data instanceof Promise)) {\n        data = Promise.resolve(data);\n      }\n      return data.then(value => {\n        if (typeof value === \"string\" || value instanceof ArrayBuffer) {\n          return new Response(value);\n        } else {\n          return value;\n        }\n      });\n    } else {\n      throw \"failed fetching recording file: url/data missing in src\";\n    }\n  }\n  async function doFetchOne(url, fetchOpts) {\n    const response = await fetch(url, fetchOpts);\n    if (!response.ok) {\n      throw `failed fetching recording from ${url}: ${response.status} ${response.statusText}`;\n    }\n    return response;\n  }\n  function delay(targetTime) {\n    let delay = targetTime * 1000 - (now() - startTime);\n    if (delay < 0) {\n      delay = 0;\n    }\n    return delay;\n  }\n  function scheduleNextEvent() {\n    const nextEvent = events[nextEventIndex];\n    if (nextEvent) {\n      eventTimeoutId = setTimeout(runNextEvent, delay(nextEvent[0]));\n    } else {\n      onEnd();\n    }\n  }\n  function runNextEvent() {\n    let event = events[nextEventIndex];\n    let elapsedWallTime;\n    do {\n      lastEventTime = event[0];\n      nextEventIndex++;\n      const stop = executeEvent(event);\n      if (stop) {\n        return;\n      }\n      event = events[nextEventIndex];\n      elapsedWallTime = now() - startTime;\n    } while (event && elapsedWallTime > event[0] * 1000);\n    scheduleNextEvent();\n  }\n  function cancelNextEvent() {\n    clearTimeout(eventTimeoutId);\n    eventTimeoutId = null;\n  }\n  function executeEvent(event) {\n    const [time, type, data] = event;\n    if (type === \"o\") {\n      feed(data);\n    } else if (type === \"i\") {\n      onInput(data);\n    } else if (type === \"m\") {\n      onMarker(data);\n      if (pauseOnMarkers) {\n        pause();\n        pauseElapsedTime = time * 1000;\n        setState(\"stopped\", {\n          reason: \"paused\"\n        });\n        return true;\n      }\n    }\n    return false;\n  }\n  function onEnd() {\n    cancelNextEvent();\n    playCount++;\n    if (loop === true || typeof loop === \"number\" && playCount < loop) {\n      nextEventIndex = 0;\n      startTime = now();\n      feed(\"\\x1bc\"); // reset terminal\n      resizeTerminalToInitialSize();\n      scheduleNextEvent();\n    } else {\n      pauseElapsedTime = duration * 1000;\n      effectiveStartAt = null;\n      setState(\"stopped\", {\n        reason: \"ended\"\n      });\n    }\n  }\n  function play() {\n    if (eventTimeoutId) return true;\n    if (events[nextEventIndex] === undefined) {\n      // ended\n      effectiveStartAt = 0;\n    }\n    if (effectiveStartAt !== null) {\n      seek(effectiveStartAt);\n    }\n    resume();\n    return true;\n  }\n  function pause() {\n    if (!eventTimeoutId) return true;\n    cancelNextEvent();\n    pauseElapsedTime = now() - startTime;\n    return true;\n  }\n  function resume() {\n    startTime = now() - pauseElapsedTime;\n    pauseElapsedTime = null;\n    scheduleNextEvent();\n  }\n  function seek(where) {\n    const isPlaying = !!eventTimeoutId;\n    pause();\n    const currentTime = (pauseElapsedTime ?? 0) / 1000;\n    if (typeof where === \"string\") {\n      if (where === \"<<\") {\n        where = currentTime - 5;\n      } else if (where === \">>\") {\n        where = currentTime + 5;\n      } else if (where === \"<<<\") {\n        where = currentTime - 0.1 * duration;\n      } else if (where === \">>>\") {\n        where = currentTime + 0.1 * duration;\n      } else if (where[where.length - 1] === \"%\") {\n        where = parseFloat(where.substring(0, where.length - 1)) / 100 * duration;\n      }\n    } else if (typeof where === \"object\") {\n      if (where.marker === \"prev\") {\n        where = findMarkerTimeBefore(currentTime) ?? 0;\n        if (isPlaying && currentTime - where < 1) {\n          where = findMarkerTimeBefore(where) ?? 0;\n        }\n      } else if (where.marker === \"next\") {\n        where = findMarkerTimeAfter(currentTime) ?? duration;\n      } else if (typeof where.marker === \"number\") {\n        const marker = markers[where.marker];\n        if (marker === undefined) {\n          throw `invalid marker index: ${where.marker}`;\n        } else {\n          where = marker[0];\n        }\n      }\n    }\n    const targetTime = Math.min(Math.max(where, 0), duration);\n    if (targetTime < lastEventTime) {\n      feed(\"\\x1bc\"); // reset terminal\n      resizeTerminalToInitialSize();\n      nextEventIndex = 0;\n      lastEventTime = 0;\n    }\n    let event = events[nextEventIndex];\n    while (event && event[0] <= targetTime) {\n      if (event[1] === \"o\") {\n        executeEvent(event);\n      }\n      lastEventTime = event[0];\n      event = events[++nextEventIndex];\n    }\n    pauseElapsedTime = targetTime * 1000;\n    effectiveStartAt = null;\n    if (isPlaying) {\n      resume();\n    }\n    return true;\n  }\n  function findMarkerTimeBefore(time) {\n    if (markers.length == 0) return;\n    let i = 0;\n    let marker = markers[i];\n    let lastMarkerTimeBefore;\n    while (marker && marker[0] < time) {\n      lastMarkerTimeBefore = marker[0];\n      marker = markers[++i];\n    }\n    return lastMarkerTimeBefore;\n  }\n  function findMarkerTimeAfter(time) {\n    if (markers.length == 0) return;\n    let i = markers.length - 1;\n    let marker = markers[i];\n    let firstMarkerTimeAfter;\n    while (marker && marker[0] > time) {\n      firstMarkerTimeAfter = marker[0];\n      marker = markers[--i];\n    }\n    return firstMarkerTimeAfter;\n  }\n  function step() {\n    let nextEvent = events[nextEventIndex++];\n    while (nextEvent !== undefined && nextEvent[1] !== \"o\") {\n      nextEvent = events[nextEventIndex++];\n    }\n    if (nextEvent === undefined) return;\n    feed(nextEvent[2]);\n    const targetTime = nextEvent[0];\n    lastEventTime = targetTime;\n    pauseElapsedTime = targetTime * 1000;\n    effectiveStartAt = null;\n  }\n  function getPoster(time) {\n    return events.filter(e => e[0] < time && e[1] === \"o\").map(e => e[2]);\n  }\n  function getCurrentTime() {\n    if (eventTimeoutId) {\n      return (now() - startTime) / 1000;\n    } else {\n      return (pauseElapsedTime ?? 0) / 1000;\n    }\n  }\n  function resizeTerminalToInitialSize() {\n    feed(`\\x1b[8;${initialRows};${initialCols};t`);\n  }\n  return {\n    init,\n    play,\n    pause,\n    seek,\n    step,\n    stop: pause,\n    getCurrentTime\n  };\n}\nfunction batcher(logger) {\n  let minFrameTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0 / 60;\n  let prevEvent;\n  return emit => {\n    let ic = 0;\n    let oc = 0;\n    return {\n      step: event => {\n        ic++;\n        if (prevEvent === undefined) {\n          prevEvent = event;\n          return;\n        }\n        if (event[1] === prevEvent[1] && event[0] - prevEvent[0] < minFrameTime) {\n          if (event[1] === \"m\" && event[2] !== \"\") {\n            prevEvent[2] = event[2];\n          } else {\n            prevEvent[2] += event[2];\n          }\n        } else {\n          emit(prevEvent);\n          prevEvent = event;\n          oc++;\n        }\n      },\n      flush: () => {\n        if (prevEvent !== undefined) {\n          emit(prevEvent);\n          oc++;\n        }\n        logger.debug(`batched ${ic} frames to ${oc} frames`);\n      }\n    };\n  };\n}\nfunction prepare(recording, logger, _ref4) {\n  let {\n    startAt = 0,\n    idleTimeLimit,\n    minFrameTime,\n    inputOffset,\n    markers_\n  } = _ref4;\n  let {\n    events\n  } = recording;\n  if (events === undefined) {\n    events = buildEvents(recording);\n  }\n  if (!(events instanceof Stream)) {\n    events = new Stream(events);\n  }\n  idleTimeLimit = idleTimeLimit ?? recording.idleTimeLimit ?? Infinity;\n  const limiterOutput = {\n    offset: 0\n  };\n  events = events.map(convertResizeEvent).transform(batcher(logger, minFrameTime)).map(timeLimiter(idleTimeLimit, startAt, limiterOutput)).map(markerWrapper());\n  if (markers_ !== undefined) {\n    markers_ = new Stream(markers_).map(normalizeMarker);\n    events = events.filter(e => e[1] !== \"m\").multiplex(markers_, (a, b) => a[0] < b[0]).map(markerWrapper());\n  }\n  events = events.toArray();\n  if (inputOffset !== undefined) {\n    events = events.map(e => e[1] === \"i\" ? [e[0] + inputOffset, e[1], e[2]] : e);\n    events.sort((a, b) => a[0] - b[0]);\n  }\n  const duration = events[events.length - 1][0];\n  const effectiveStartAt = startAt - limiterOutput.offset;\n  return {\n    ...recording,\n    events,\n    duration,\n    effectiveStartAt\n  };\n}\nfunction buildEvents(_ref5) {\n  let {\n    output = [],\n    input = [],\n    markers = []\n  } = _ref5;\n  const o = new Stream(output).map(e => [e[0], \"o\", e[1]]);\n  const i = new Stream(input).map(e => [e[0], \"i\", e[1]]);\n  const m = new Stream(markers).map(normalizeMarker);\n  return o.multiplex(i, (a, b) => a[0] < b[0]).multiplex(m, (a, b) => a[0] < b[0]);\n}\nfunction convertResizeEvent(e) {\n  if (e[1] === \"r\") {\n    const [cols, rows] = e[2].split(\"x\");\n    return [e[0], \"o\", `\\x1b[8;${rows};${cols};t`];\n  } else {\n    return e;\n  }\n}\nfunction normalizeMarker(m) {\n  return typeof m === \"number\" ? [m, \"m\", \"\"] : [m[0], \"m\", m[1]];\n}\nfunction timeLimiter(idleTimeLimit, startAt, output) {\n  let prevT = 0;\n  let shift = 0;\n  return function (e) {\n    const delay = e[0] - prevT;\n    const delta = delay - idleTimeLimit;\n    prevT = e[0];\n    if (delta > 0) {\n      shift += delta;\n      if (e[0] < startAt) {\n        output.offset += delta;\n      }\n    }\n    return [e[0] - shift, e[1], e[2]];\n  };\n}\nfunction markerWrapper() {\n  let i = 0;\n  return function (e) {\n    if (e[1] === \"m\") {\n      return [e[0], e[1], {\n        index: i++,\n        time: e[0],\n        label: e[2]\n      }];\n    } else {\n      return e;\n    }\n  };\n}\nfunction dump(recording, filename) {\n  const link = document.createElement(\"a\");\n  const events = recording.events.map(e => e[1] === \"m\" ? [e[0], e[1], e[2].label] : e);\n  const asciicast = unparseAsciicastV2({\n    ...recording,\n    events\n  });\n  link.href = URL.createObjectURL(new Blob([asciicast], {\n    type: \"text/plain\"\n  }));\n  link.download = filename;\n  link.click();\n}\n\nfunction clock(_ref, _ref2, _ref3) {\n  let {\n    hourColor = 3,\n    minuteColor = 4,\n    separatorColor = 9\n  } = _ref;\n  let {\n    feed\n  } = _ref2;\n  let {\n    cols = 5,\n    rows = 1\n  } = _ref3;\n  const middleRow = Math.floor(rows / 2);\n  const leftPad = Math.floor(cols / 2) - 2;\n  const setupCursor = `\\x1b[?25l\\x1b[1m\\x1b[${middleRow}B`;\n  let intervalId;\n  const getCurrentTime = () => {\n    const d = new Date();\n    const h = d.getHours();\n    const m = d.getMinutes();\n    const seqs = [];\n    seqs.push(\"\\r\");\n    for (let i = 0; i < leftPad; i++) {\n      seqs.push(\" \");\n    }\n    seqs.push(`\\x1b[3${hourColor}m`);\n    if (h < 10) {\n      seqs.push(\"0\");\n    }\n    seqs.push(`${h}`);\n    seqs.push(`\\x1b[3${separatorColor};5m:\\x1b[25m`);\n    seqs.push(`\\x1b[3${minuteColor}m`);\n    if (m < 10) {\n      seqs.push(\"0\");\n    }\n    seqs.push(`${m}`);\n    return seqs;\n  };\n  const updateTime = () => {\n    getCurrentTime().forEach(feed);\n  };\n  return {\n    init: () => {\n      const duration = 24 * 60;\n      const poster = [setupCursor].concat(getCurrentTime());\n      return {\n        cols,\n        rows,\n        duration,\n        poster\n      };\n    },\n    play: () => {\n      feed(setupCursor);\n      updateTime();\n      intervalId = setInterval(updateTime, 1000);\n      return true;\n    },\n    stop: () => {\n      clearInterval(intervalId);\n    },\n    getCurrentTime: () => {\n      const d = new Date();\n      return d.getHours() * 60 + d.getMinutes();\n    }\n  };\n}\n\nfunction random(src, _ref) {\n  let {\n    feed,\n    setTimeout\n  } = _ref;\n  const base = \" \".charCodeAt(0);\n  const range = \"~\".charCodeAt(0) - base;\n  let timeoutId;\n  const schedule = () => {\n    const t = Math.pow(5, Math.random() * 4);\n    timeoutId = setTimeout(print, t);\n  };\n  const print = () => {\n    schedule();\n    const char = String.fromCharCode(base + Math.floor(Math.random() * range));\n    feed(char);\n  };\n  return () => {\n    schedule();\n    return () => clearInterval(timeoutId);\n  };\n}\n\nfunction benchmark(_ref, _ref2) {\n  let {\n    url,\n    iterations = 10\n  } = _ref;\n  let {\n    feed,\n    setState,\n    now\n  } = _ref2;\n  let data;\n  let byteCount = 0;\n  return {\n    async init() {\n      const recording = await parse$2(await fetch(url));\n      const {\n        cols,\n        rows,\n        events\n      } = recording;\n      data = Array.from(events).filter(_ref3 => {\n        let [_time, type, _text] = _ref3;\n        return type === \"o\";\n      }).map(_ref4 => {\n        let [time, _type, text] = _ref4;\n        return [time, text];\n      });\n      const duration = data[data.length - 1][0];\n      for (const [_, text] of data) {\n        byteCount += new Blob([text]).size;\n      }\n      return {\n        cols,\n        rows,\n        duration\n      };\n    },\n    play() {\n      const startTime = now();\n      for (let i = 0; i < iterations; i++) {\n        for (const [_, text] of data) {\n          feed(text);\n        }\n        feed(\"\\x1bc\"); // reset terminal\n      }\n\n      const endTime = now();\n      const duration = (endTime - startTime) / 1000;\n      const throughput = byteCount * iterations / duration;\n      const throughputMbs = byteCount / (1024 * 1024) * iterations / duration;\n      console.info(\"benchmark: result\", {\n        byteCount,\n        iterations,\n        duration,\n        throughput,\n        throughputMbs\n      });\n      setTimeout(() => {\n        setState(\"stopped\", {\n          reason: \"ended\"\n        });\n      }, 0);\n      return true;\n    }\n  };\n}\n\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.onPush = undefined;\n  }\n  push(item) {\n    this.items.push(item);\n    if (this.onPush !== undefined) {\n      this.onPush(this.popAll());\n      this.onPush = undefined;\n    }\n  }\n  popAll() {\n    if (this.items.length > 0) {\n      const items = this.items;\n      this.items = [];\n      return items;\n    } else {\n      const thiz = this;\n      return new Promise(resolve => {\n        thiz.onPush = resolve;\n      });\n    }\n  }\n}\n\nfunction getBuffer(bufferTime, feed, setTime, baseStreamTime, minFrameTime, logger) {\n  if (bufferTime === 0) {\n    logger.debug(\"using no buffer\");\n    return nullBuffer(feed);\n  } else {\n    let getBufferTime;\n    if (typeof bufferTime === \"number\") {\n      logger.debug(`using fixed time buffer (${bufferTime} ms)`);\n      getBufferTime = _latency => bufferTime;\n    } else {\n      logger.debug(\"using adaptive buffer\");\n      getBufferTime = adaptiveBufferTimeProvider(logger);\n    }\n    return buffer(getBufferTime, feed, setTime, logger, baseStreamTime ?? 0.0, minFrameTime);\n  }\n}\nfunction nullBuffer(feed) {\n  return {\n    pushEvent(event) {\n      if (event[1] === \"o\") {\n        feed(event[2]);\n      }\n    },\n    pushText(text) {\n      feed(text);\n    },\n    stop() {}\n  };\n}\nfunction buffer(getBufferTime, feed, setTime, logger, baseStreamTime) {\n  let minFrameTime = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1.0 / 60;\n  let epoch = performance.now() - baseStreamTime * 1000;\n  let bufferTime = getBufferTime(0);\n  const queue = new Queue();\n  minFrameTime *= 1000;\n  let prevElapsedStreamTime = -minFrameTime;\n  let stop = false;\n  function elapsedWallTime() {\n    return performance.now() - epoch;\n  }\n  setTimeout(async () => {\n    while (!stop) {\n      const events = await queue.popAll();\n      if (stop) return;\n      for (const event of events) {\n        const elapsedStreamTime = event[0] * 1000 + bufferTime;\n        if (elapsedStreamTime - prevElapsedStreamTime < minFrameTime) {\n          feed(event[2]);\n          continue;\n        }\n        const delay = elapsedStreamTime - elapsedWallTime();\n        if (delay > 0) {\n          await sleep(delay);\n          if (stop) return;\n        }\n        setTime(event[0]);\n        feed(event[2]);\n        prevElapsedStreamTime = elapsedStreamTime;\n      }\n    }\n  }, 0);\n  return {\n    pushEvent(event) {\n      let latency = elapsedWallTime() - event[0] * 1000;\n      if (latency < 0) {\n        logger.debug(`correcting epoch by ${latency} ms`);\n        epoch += latency;\n        latency = 0;\n      }\n      bufferTime = getBufferTime(latency);\n      if (event[1] === \"o\") {\n        queue.push(event);\n      } else if (event[1] === \"r\") {\n        const [cols, rows] = event[2].split(\"x\");\n        queue.push([event[0], \"o\", `\\x1b[8;${rows};${cols};t`]);\n      }\n    },\n    pushText(text) {\n      queue.push([elapsedWallTime(), \"o\", text]);\n    },\n    stop() {\n      stop = true;\n      queue.push(undefined);\n    }\n  };\n}\nfunction sleep(t) {\n  return new Promise(resolve => {\n    setTimeout(resolve, t);\n  });\n}\nconst BUFFER_TIME_MULTIPLIER = 1.5;\nconst INITIAL_BUFFER_TIME = 10;\nconst MAX_BUFFER_LEVEL = 12;\nconst LATENCY_WINDOW_SIZE = 10;\nfunction adaptiveBufferTimeProvider(logger) {\n  let bufferTime = INITIAL_BUFFER_TIME;\n  let bufferLevel = 0;\n  let latencies = [];\n  return latency => {\n    latencies.push(latency);\n    if (latencies.length > LATENCY_WINDOW_SIZE) {\n      latencies = latencies.slice(-LATENCY_WINDOW_SIZE);\n      const avgLatency = avg(latencies);\n      if (bufferLevel < MAX_BUFFER_LEVEL && avgLatency > bufferTime) {\n        bufferTime = calcBufferTime(bufferLevel += 1);\n        logger.debug(`latency increased, raising bufferTime to ${bufferTime} ms`);\n      } else if (bufferLevel == 1 && avgLatency < calcBufferTime(bufferLevel - 1) || bufferLevel > 1 && avgLatency < calcBufferTime(bufferLevel - 2)) {\n        bufferTime = calcBufferTime(bufferLevel -= 1);\n        logger.debug(`latency decreased, lowering bufferTime to ${bufferTime} ms`);\n      }\n    }\n    return bufferTime;\n  };\n}\nfunction avg(numbers) {\n  return numbers.reduce((prev, cur) => prev + cur, 0) / numbers.length;\n}\nfunction calcBufferTime(level) {\n  return INITIAL_BUFFER_TIME * BUFFER_TIME_MULTIPLIER ** level;\n}\n\nfunction exponentialDelay(attempt) {\n  return Math.min(500 * Math.pow(2, attempt), 5000);\n}\nfunction websocket(_ref, _ref2) {\n  let {\n    url,\n    bufferTime,\n    reconnectDelay = exponentialDelay,\n    minFrameTime\n  } = _ref;\n  let {\n    feed,\n    reset,\n    setState,\n    logger\n  } = _ref2;\n  logger = new PrefixedLogger(logger, \"websocket: \");\n  const utfDecoder = new TextDecoder();\n  let socket;\n  let buf;\n  let clock = new NullClock();\n  let reconnectAttempt = 0;\n  let successfulConnectionTimeout;\n  let stop = false;\n  function initBuffer(baseStreamTime) {\n    if (buf !== undefined) buf.stop();\n    buf = getBuffer(bufferTime, feed, t => clock.setTime(t), baseStreamTime, minFrameTime, logger);\n  }\n  function detectProtocol(event) {\n    if (typeof event.data === \"string\") {\n      logger.info(\"activating asciicast-compatible handler\");\n      initBuffer();\n      socket.onmessage = handleJsonMessage;\n      handleJsonMessage(event);\n    } else {\n      const arr = new Uint8Array(event.data);\n      if (arr[0] == 0x41 && arr[1] == 0x4c && arr[2] == 0x69 && arr[3] == 0x53) {\n        // 'ALiS'\n        if (arr[4] == 1) {\n          logger.info(\"activating ALiS v1 handler\");\n          socket.onmessage = handleStreamMessage;\n        } else {\n          logger.warn(`unsupported ALiS version (${arr[4]})`);\n          socket.close();\n        }\n      } else {\n        logger.info(\"activating raw text handler\");\n        initBuffer();\n        const text = utfDecoder.decode(arr);\n        const size = sizeFromResizeSeq(text) ?? sizeFromScriptStartMessage(text);\n        if (size !== undefined) {\n          const [cols, rows] = size;\n          handleResetMessage(cols, rows, 0, undefined);\n        }\n        socket.onmessage = handleRawTextMessage;\n        handleRawTextMessage(event);\n      }\n    }\n  }\n  function sizeFromResizeSeq(text) {\n    const match = text.match(/\\x1b\\[8;(\\d+);(\\d+)t/);\n    if (match !== null) {\n      return [parseInt(match[2], 10), parseInt(match[1], 10)];\n    }\n  }\n  function sizeFromScriptStartMessage(text) {\n    const match = text.match(/\\[.*COLUMNS=\"(\\d{1,3})\" LINES=\"(\\d{1,3})\".*\\]/);\n    if (match !== null) {\n      return [parseInt(match[1], 10), parseInt(match[2], 10)];\n    }\n  }\n  function handleJsonMessage(event) {\n    const e = JSON.parse(event.data);\n    if (Array.isArray(e)) {\n      buf.pushEvent(e);\n    } else if (e.cols !== undefined || e.width !== undefined) {\n      handleResetMessage(e.cols ?? e.width, e.rows ?? e.height, e.time, e.init ?? undefined);\n    } else if (e.status === \"offline\") {\n      handleOfflineMessage();\n    }\n  }\n  const THEME_LEN = 54; // (2 + 16) * 3\n\n  function handleStreamMessage(event) {\n    const buffer = event.data;\n    const view = new DataView(buffer);\n    const type = view.getUint8(0);\n    let offset = 1;\n    if (type === 0x01) {\n      // reset\n      const cols = view.getUint16(offset, true);\n      offset += 2;\n      const rows = view.getUint16(offset, true);\n      offset += 2;\n      const time = view.getFloat32(offset, true);\n      offset += 4;\n      const themeFormat = view.getUint8(offset);\n      offset += 1;\n      let theme;\n      if (themeFormat === 1) {\n        theme = parseTheme(new Uint8Array(buffer, offset, THEME_LEN));\n        offset += THEME_LEN;\n      }\n      const initLen = view.getUint32(offset, true);\n      offset += 4;\n      let init;\n      if (initLen > 0) {\n        init = utfDecoder.decode(new Uint8Array(buffer, offset, initLen));\n        offset += initLen;\n      }\n      handleResetMessage(cols, rows, time, init, theme);\n    } else if (type === 0x6f) {\n      // 'o' - output\n      const time = view.getFloat32(1, true);\n      const len = view.getUint32(5, true);\n      const text = utfDecoder.decode(new Uint8Array(buffer, 9, len));\n      buf.pushEvent([time, \"o\", text]);\n    } else if (type === 0x72) {\n      // 'r' - resize\n      const time = view.getFloat32(1, true);\n      const cols = view.getUint16(5, true);\n      const rows = view.getUint16(7, true);\n      buf.pushEvent([time, \"r\", `${cols}x${rows}`]);\n    } else if (type === 0x04) {\n      // offline (EOT)\n      handleOfflineMessage();\n    } else {\n      logger.debug(`unknown frame type: ${type}`);\n    }\n  }\n  function parseTheme(arr) {\n    const foreground = hexColor(arr[0], arr[1], arr[2]);\n    const background = hexColor(arr[3], arr[4], arr[5]);\n    const palette = [];\n    for (let i = 0; i < 16; i++) {\n      palette.push(hexColor(arr[i * 3 + 6], arr[i * 3 + 7], arr[i * 3 + 8]));\n    }\n    return {\n      foreground,\n      background,\n      palette\n    };\n  }\n  function hexColor(r, g, b) {\n    return `#${byteToHex(r)}${byteToHex(g)}${byteToHex(b)}`;\n  }\n  function byteToHex(value) {\n    return value.toString(16).padStart(2, \"0\");\n  }\n  function handleRawTextMessage(event) {\n    buf.pushText(utfDecoder.decode(event.data));\n  }\n  function handleResetMessage(cols, rows, time, init, theme) {\n    logger.debug(`stream reset (${cols}x${rows} @${time})`);\n    setState(\"playing\");\n    initBuffer(time);\n    reset(cols, rows, init, theme);\n    clock = new Clock();\n    if (typeof time === \"number\") {\n      clock.setTime(time);\n    }\n  }\n  function handleOfflineMessage() {\n    logger.info(\"stream offline\");\n    setState(\"offline\");\n    clock = new NullClock();\n  }\n  function connect() {\n    socket = new WebSocket(url);\n    socket.binaryType = \"arraybuffer\";\n    socket.onopen = () => {\n      logger.info(\"opened\");\n      successfulConnectionTimeout = setTimeout(() => {\n        reconnectAttempt = 0;\n      }, 1000);\n    };\n    socket.onmessage = detectProtocol;\n    socket.onclose = event => {\n      if (stop || event.code === 1000 || event.code === 1005) {\n        logger.info(\"closed\");\n        setState(\"stopped\", {\n          reason: \"ended\",\n          message: \"Stream ended\"\n        });\n      } else {\n        clearTimeout(successfulConnectionTimeout);\n        const delay = reconnectDelay(reconnectAttempt++);\n        logger.info(`unclean close, reconnecting in ${delay}...`);\n        setState(\"loading\");\n        setTimeout(connect, delay);\n      }\n    };\n  }\n  return {\n    play: () => {\n      connect();\n    },\n    stop: () => {\n      stop = true;\n      if (buf !== undefined) buf.stop();\n      if (socket !== undefined) socket.close();\n    },\n    getCurrentTime: () => clock.getTime()\n  };\n}\n\nfunction eventsource(_ref, _ref2) {\n  let {\n    url,\n    bufferTime,\n    minFrameTime\n  } = _ref;\n  let {\n    feed,\n    reset,\n    setState,\n    logger\n  } = _ref2;\n  logger = new PrefixedLogger(logger, \"eventsource: \");\n  let es;\n  let buf;\n  let clock = new NullClock();\n  function initBuffer(baseStreamTime) {\n    if (buf !== undefined) buf.stop();\n    buf = getBuffer(bufferTime, feed, t => clock.setTime(t), baseStreamTime, minFrameTime, logger);\n  }\n  return {\n    play: () => {\n      es = new EventSource(url);\n      es.addEventListener(\"open\", () => {\n        logger.info(\"opened\");\n        initBuffer();\n      });\n      es.addEventListener(\"error\", e => {\n        logger.info(\"errored\");\n        logger.debug({\n          e\n        });\n        setState(\"loading\");\n      });\n      es.addEventListener(\"message\", event => {\n        const e = JSON.parse(event.data);\n        if (Array.isArray(e)) {\n          buf.pushEvent(e);\n        } else if (e.cols !== undefined || e.width !== undefined) {\n          const cols = e.cols ?? e.width;\n          const rows = e.rows ?? e.height;\n          logger.debug(`vt reset (${cols}x${rows})`);\n          setState(\"playing\");\n          initBuffer(e.time);\n          reset(cols, rows, e.init ?? undefined);\n          clock = new Clock();\n          if (typeof e.time === \"number\") {\n            clock.setTime(e.time);\n          }\n        } else if (e.state === \"offline\") {\n          logger.info(\"stream offline\");\n          setState(\"offline\");\n          clock = new NullClock();\n        }\n      });\n      es.addEventListener(\"done\", () => {\n        logger.info(\"closed\");\n        es.close();\n        setState(\"stopped\", {\n          reason: \"ended\"\n        });\n      });\n    },\n    stop: () => {\n      if (buf !== undefined) buf.stop();\n      if (es !== undefined) es.close();\n    },\n    getCurrentTime: () => clock.getTime()\n  };\n}\n\nasync function parse$1(responses, _ref) {\n  let {\n    encoding\n  } = _ref;\n  const textDecoder = new TextDecoder(encoding);\n  let cols;\n  let rows;\n  let timing = (await responses[0].text()).split(\"\\n\").filter(line => line.length > 0).map(line => line.split(\" \"));\n  if (timing[0].length < 3) {\n    timing = timing.map(entry => [\"O\", entry[0], entry[1]]);\n  }\n  const buffer = await responses[1].arrayBuffer();\n  const array = new Uint8Array(buffer);\n  const dataOffset = array.findIndex(byte => byte == 0x0a) + 1;\n  const header = textDecoder.decode(array.subarray(0, dataOffset));\n  const sizeMatch = header.match(/COLUMNS=\"(\\d+)\" LINES=\"(\\d+)\"/);\n  if (sizeMatch !== null) {\n    cols = parseInt(sizeMatch[1], 10);\n    rows = parseInt(sizeMatch[2], 10);\n  }\n  const stdout = {\n    array,\n    cursor: dataOffset\n  };\n  let stdin = stdout;\n  if (responses[2] !== undefined) {\n    const buffer = await responses[2].arrayBuffer();\n    const array = new Uint8Array(buffer);\n    stdin = {\n      array,\n      cursor: dataOffset\n    };\n  }\n  const events = [];\n  let time = 0;\n  for (const entry of timing) {\n    time += parseFloat(entry[1]);\n    if (entry[0] === \"O\") {\n      const count = parseInt(entry[2], 10);\n      const bytes = stdout.array.subarray(stdout.cursor, stdout.cursor + count);\n      const text = textDecoder.decode(bytes);\n      events.push([time, \"o\", text]);\n      stdout.cursor += count;\n    } else if (entry[0] === \"I\") {\n      const count = parseInt(entry[2], 10);\n      const bytes = stdin.array.subarray(stdin.cursor, stdin.cursor + count);\n      const text = textDecoder.decode(bytes);\n      events.push([time, \"i\", text]);\n      stdin.cursor += count;\n    } else if (entry[0] === \"S\" && entry[2] === \"SIGWINCH\") {\n      const cols = parseInt(entry[4].slice(5), 10);\n      const rows = parseInt(entry[3].slice(5), 10);\n      events.push([time, \"r\", `${cols}x${rows}`]);\n    } else if (entry[0] === \"H\" && entry[2] === \"COLUMNS\") {\n      cols = parseInt(entry[3], 10);\n    } else if (entry[0] === \"H\" && entry[2] === \"LINES\") {\n      rows = parseInt(entry[3], 10);\n    }\n  }\n  cols = cols ?? 80;\n  rows = rows ?? 24;\n  return {\n    cols,\n    rows,\n    events\n  };\n}\n\nasync function parse(response, _ref) {\n  let {\n    encoding\n  } = _ref;\n  const textDecoder = new TextDecoder(encoding);\n  const buffer = await response.arrayBuffer();\n  const array = new Uint8Array(buffer);\n  const firstFrame = parseFrame(array);\n  const baseTime = firstFrame.time;\n  const firstFrameText = textDecoder.decode(firstFrame.data);\n  const sizeMatch = firstFrameText.match(/\\x1b\\[8;(\\d+);(\\d+)t/);\n  const events = [];\n  let cols = 80;\n  let rows = 24;\n  if (sizeMatch !== null) {\n    cols = parseInt(sizeMatch[2], 10);\n    rows = parseInt(sizeMatch[1], 10);\n  }\n  let cursor = 0;\n  let frame = parseFrame(array);\n  while (frame !== undefined) {\n    const time = frame.time - baseTime;\n    const text = textDecoder.decode(frame.data);\n    events.push([time, \"o\", text]);\n    cursor += frame.len;\n    frame = parseFrame(array.subarray(cursor));\n  }\n  return {\n    cols,\n    rows,\n    events\n  };\n}\nfunction parseFrame(array) {\n  if (array.length < 13) return;\n  const time = parseTimestamp(array.subarray(0, 8));\n  const len = parseNumber(array.subarray(8, 12));\n  const data = array.subarray(12, 12 + len);\n  return {\n    time,\n    data,\n    len: len + 12\n  };\n}\nfunction parseNumber(array) {\n  return array[0] + array[1] * 256 + array[2] * 256 * 256 + array[3] * 256 * 256 * 256;\n}\nfunction parseTimestamp(array) {\n  const sec = parseNumber(array.subarray(0, 4));\n  const usec = parseNumber(array.subarray(4, 8));\n  return sec + usec / 1000000;\n}\n\nconst drivers = new Map([[\"benchmark\", benchmark], [\"clock\", clock], [\"eventsource\", eventsource], [\"random\", random], [\"recording\", recording], [\"websocket\", websocket]]);\nconst parsers = new Map([[\"asciicast\", parse$2], [\"typescript\", parse$1], [\"ttyrec\", parse]]);\nfunction create(src, elem) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const logger = opts.logger ?? new DummyLogger();\n  const core = new Core(getDriver(src), {\n    logger: logger,\n    cols: opts.cols,\n    rows: opts.rows,\n    loop: opts.loop,\n    speed: opts.speed,\n    preload: opts.preload,\n    startAt: opts.startAt,\n    poster: opts.poster,\n    markers: opts.markers,\n    pauseOnMarkers: opts.pauseOnMarkers,\n    idleTimeLimit: opts.idleTimeLimit\n  });\n  const metrics = measureTerminal(opts.terminalFontFamily, opts.terminalLineHeight);\n  const props = {\n    logger: logger,\n    core: core,\n    cols: opts.cols,\n    rows: opts.rows,\n    fit: opts.fit,\n    controls: opts.controls ?? \"auto\",\n    autoPlay: opts.autoPlay ?? opts.autoplay,\n    terminalFontSize: opts.terminalFontSize,\n    terminalFontFamily: opts.terminalFontFamily,\n    terminalLineHeight: opts.terminalLineHeight,\n    theme: opts.theme,\n    ...metrics\n  };\n  let el;\n  const dispose = render(() => {\n    el = createComponent(Player, props);\n    return el;\n  }, elem);\n  const player = {\n    el: el,\n    dispose: dispose,\n    getCurrentTime: () => core.getCurrentTime(),\n    getDuration: () => core.getDuration(),\n    play: () => core.play(),\n    pause: () => core.pause(),\n    seek: pos => core.seek(pos)\n  };\n  player.addEventListener = (name, callback) => {\n    return core.addEventListener(name, callback.bind(player));\n  };\n  return player;\n}\nfunction getDriver(src) {\n  if (typeof src === \"function\") return src;\n  if (typeof src === \"string\") {\n    if (src.substring(0, 5) == \"ws://\" || src.substring(0, 6) == \"wss://\") {\n      src = {\n        driver: \"websocket\",\n        url: src\n      };\n    } else if (src.substring(0, 6) == \"clock:\") {\n      src = {\n        driver: \"clock\"\n      };\n    } else if (src.substring(0, 7) == \"random:\") {\n      src = {\n        driver: \"random\"\n      };\n    } else if (src.substring(0, 10) == \"benchmark:\") {\n      src = {\n        driver: \"benchmark\",\n        url: src.substring(10)\n      };\n    } else {\n      src = {\n        driver: \"recording\",\n        url: src\n      };\n    }\n  }\n  if (src.driver === undefined) {\n    src.driver = \"recording\";\n  }\n  if (src.driver == \"recording\") {\n    if (src.parser === undefined) {\n      src.parser = \"asciicast\";\n    }\n    if (typeof src.parser === \"string\") {\n      if (parsers.has(src.parser)) {\n        src.parser = parsers.get(src.parser);\n      } else {\n        throw `unknown parser: ${src.parser}`;\n      }\n    }\n  }\n  if (drivers.has(src.driver)) {\n    const driver = drivers.get(src.driver);\n    return (callbacks, opts) => driver(src, callbacks, opts);\n  } else {\n    throw `unsupported driver: ${JSON.stringify(src)}`;\n  }\n}\nfunction measureTerminal(fontFamily, lineHeight) {\n  const cols = 80;\n  const rows = 24;\n  const div = document.createElement(\"div\");\n  div.style.height = \"0px\";\n  div.style.overflow = \"hidden\";\n  div.style.fontSize = \"15px\"; // must match font-size of div.asciinema-player in CSS\n  document.body.appendChild(div);\n  let el;\n  const dispose = render(() => {\n    el = createComponent(Terminal, {\n      cols: cols,\n      rows: rows,\n      lineHeight: lineHeight,\n      fontFamily: fontFamily,\n      lines: []\n    });\n    return el;\n  }, div);\n  const metrics = {\n    charW: el.clientWidth / cols,\n    charH: el.clientHeight / rows,\n    bordersW: el.offsetWidth - el.clientWidth,\n    bordersH: el.offsetHeight - el.clientHeight\n  };\n  dispose();\n  document.body.removeChild(div);\n  return metrics;\n}\n\nexport { create };\n","// extracted by mini-css-extract-plugin\nexport {};"],"names":[],"sourceRoot":""}