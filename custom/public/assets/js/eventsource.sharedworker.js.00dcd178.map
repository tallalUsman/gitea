{"version":3,"file":"js/eventsource.sharedworker.js","mappings":"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","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/make namespace object","webpack:///./web_src/js/features/eventsource.sharedworker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const sourcesByUrl = {};\nconst sourcesByPort = {};\n\nclass Source {\n  constructor(url) {\n    this.url = url;\n    this.eventSource = new EventSource(url);\n    this.listening = {};\n    this.clients = [];\n    this.listen('open');\n    this.listen('close');\n    this.listen('logout');\n    this.listen('notification-count');\n    this.listen('stopwatches');\n    this.listen('error');\n  }\n\n  register(port) {\n    if (this.clients.includes(port)) return;\n\n    this.clients.push(port);\n\n    port.postMessage({\n      type: 'status',\n      message: `registered to ${this.url}`,\n    });\n  }\n\n  deregister(port) {\n    const portIdx = this.clients.indexOf(port);\n    if (portIdx < 0) {\n      return this.clients.length;\n    }\n    this.clients.splice(portIdx, 1);\n    return this.clients.length;\n  }\n\n  close() {\n    if (!this.eventSource) return;\n\n    this.eventSource.close();\n    this.eventSource = null;\n  }\n\n  listen(eventType) {\n    if (this.listening[eventType]) return;\n    this.listening[eventType] = true;\n    this.eventSource.addEventListener(eventType, (event) => {\n      this.notifyClients({\n        type: eventType,\n        data: event.data,\n      });\n    });\n  }\n\n  notifyClients(event) {\n    for (const client of this.clients) {\n      client.postMessage(event);\n    }\n  }\n\n  status(port) {\n    port.postMessage({\n      type: 'status',\n      message: `url: ${this.url} readyState: ${this.eventSource.readyState}`,\n    });\n  }\n}\n\nself.addEventListener('connect', (e) => {\n  for (const port of e.ports) {\n    port.addEventListener('message', (event) => {\n      if (!self.EventSource) {\n        // some browsers (like PaleMoon, Firefox<53) don't support EventSource in SharedWorkerGlobalScope.\n        // this event handler needs EventSource when doing \"new Source(url)\", so just post a message back to the caller,\n        // in case the caller would like to use a fallback method to do its work.\n        port.postMessage({type: 'no-event-source'});\n        return;\n      }\n      if (event.data.type === 'start') {\n        const url = event.data.url;\n        if (sourcesByUrl[url]) {\n          // we have a Source registered to this url\n          const source = sourcesByUrl[url];\n          source.register(port);\n          sourcesByPort[port] = source;\n          return;\n        }\n        let source = sourcesByPort[port];\n        if (source) {\n          if (source.eventSource && source.url === url) return;\n\n          // How this has happened I don't understand...\n          // deregister from that source\n          const count = source.deregister(port);\n          // Clean-up\n          if (count === 0) {\n            source.close();\n            sourcesByUrl[source.url] = null;\n          }\n        }\n        // Create a new Source\n        source = new Source(url);\n        source.register(port);\n        sourcesByUrl[url] = source;\n        sourcesByPort[port] = source;\n      } else if (event.data.type === 'listen') {\n        const source = sourcesByPort[port];\n        source.listen(event.data.eventType);\n      } else if (event.data.type === 'close') {\n        const source = sourcesByPort[port];\n\n        if (!source) return;\n\n        const count = source.deregister(port);\n        if (count === 0) {\n          source.close();\n          sourcesByUrl[source.url] = null;\n          sourcesByPort[port] = null;\n        }\n      } else if (event.data.type === 'status') {\n        const source = sourcesByPort[port];\n        if (!source) {\n          port.postMessage({\n            type: 'status',\n            message: 'not connected',\n          });\n          return;\n        }\n        source.status(port);\n      } else {\n        // just send it back\n        port.postMessage({\n          type: 'error',\n          message: `received but don't know how to handle: ${event.data}`,\n        });\n      }\n    });\n    port.start();\n  }\n});\n"],"names":["source"],"sourceRoot":""}